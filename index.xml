<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>netmemo.github.io on netmemo.github.io</title>
    <link>https://netmemo.github.io/</link>
    <description>Recent content in netmemo.github.io on netmemo.github.io</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>No&amp;euml;l Boul&amp;egrave;ne &amp;copy; 2021. This blog is strictly personnal and opinions expressed here are only mine and doesn&amp;#39;t reflect those of my past, current or futur employers. No warranty whatsoever is made that any of the posts are accurate. There is absolutely no assurance (apart from author&amp;acute;s professional integrity) that any statement contained in a post is true, correct or precise.</copyright>
    <lastBuildDate>Sun, 15 Oct 2017 00:00:00 +0200</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>CUE lang and HCL map key validation</title>
      <link>https://netmemo.github.io/post/cuelang-first/</link>
      <pubDate>Thu, 10 Nov 2022 09:15:33 +0100</pubDate>
      
      <guid>https://netmemo.github.io/post/cuelang-first/</guid>
      <description>

&lt;h1 id=&#34;context&#34;&gt;Context&lt;/h1&gt;

&lt;p&gt;I&amp;rsquo;m just starting to play with CUE lang to assess the benefit it can bring to the automation I&amp;rsquo;m doing.
This is a short memo to remember how to do dictionary key validation with CUE lang and a little bit more.&lt;/p&gt;

&lt;p&gt;My starting point was to do naming convention validation with CUE lang. I have the following data model in my Terraform files.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;subnets = {
  &amp;quot;sub-primary&amp;quot;   = { &amp;quot;subnet&amp;quot; = [&amp;quot;10.0.0.0&amp;quot;,&amp;quot;10.0.1.0&amp;quot;], &amp;quot;mask&amp;quot;= 24, &amp;quot;router&amp;quot; = &amp;quot;rtr-primary&amp;quot;   },
  &amp;quot;sub-secondary&amp;quot; = { &amp;quot;subnet&amp;quot; = [&amp;quot;10.0.2.0&amp;quot;]           , &amp;quot;mask&amp;quot;= 24, &amp;quot;router&amp;quot; = &amp;quot;rtr-secondary&amp;quot; }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First I needed to transform my HCL data model into something Cue was able to understand so I choose to transform it in JSON.
Only replacing = with : and adding double quotes around every string field do the trick.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;subnets&amp;quot; : {
    &amp;quot;sub-primary&amp;quot;   : { &amp;quot;subnet&amp;quot; : [&amp;quot;10.0.0.0&amp;quot;,&amp;quot;10.0.1.0&amp;quot;], &amp;quot;mask&amp;quot; : 24, &amp;quot;router&amp;quot; : &amp;quot;rtr-primary&amp;quot;   },
    &amp;quot;sub-secondary&amp;quot; : { &amp;quot;subnet&amp;quot; : [&amp;quot;10.0.2.0&amp;quot;]           , &amp;quot;mask&amp;quot; : 24, &amp;quot;router&amp;quot; : &amp;quot;rtr-secondary&amp;quot; }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;validation-of-the-keys-s-values&#34;&gt;Validation of the keys&amp;rsquo;s values.&lt;/h1&gt;

&lt;p&gt;We can write the simplest JSON file and CUE schema below to first see how to validate the name of the keys.&lt;/p&gt;

&lt;h4 id=&#34;json-file&#34;&gt;JSON file&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;{                         
  &amp;quot;subnets&amp;quot;: {            
     &amp;quot;mytest1&amp;quot;: &amp;quot;blabla1&amp;quot;,
     &amp;quot;mytest2&amp;quot;: &amp;quot;blabla2&amp;quot; 
  }                       
}                         
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;cue-schema&#34;&gt;CUE Schema&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;#subnetstruct: {
	[string]: string 
}
subnets: #subnetstruct
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;subnets:&lt;br /&gt;
&lt;a href=&#34;https://cuelang.org/docs/references/spec/#identifiers&#34;&gt;Identifier&lt;/a&gt; that declares a variable named &lt;strong&gt;subnets&lt;/strong&gt;. That identifier reference the &lt;strong&gt;#subnetstruct&lt;/strong&gt; &lt;a href=&#34;https://cuelang.org/docs/references/spec/#definitions-and-hidden-fields&#34;&gt;definition&lt;/a&gt; which defines a &lt;a href=&#34;https://cuelang.org/docs/references/spec/#structs&#34;&gt;struct&lt;/a&gt;.
If you then have a &lt;strong&gt;subnets&lt;/strong&gt; variable in your JSON file, then it MUST match the &lt;a href=&#34;https://cuelang.org/docs/references/spec/#structs&#34;&gt;struct&lt;/a&gt; defined otherwise the validation command will failed.&lt;/li&gt;
&lt;li&gt;#subnetstruct&lt;br /&gt;
This is the &lt;a href=&#34;https://cuelang.org/docs/references/spec/#definitions-and-hidden-fields&#34;&gt;definition&lt;/a&gt; of our &lt;a href=&#34;https://cuelang.org/docs/references/spec/#structs&#34;&gt;struct&lt;/a&gt;. The &lt;a href=&#34;https://cuelang.org/docs/references/spec/#structs&#34;&gt;struct&lt;/a&gt; contains a &lt;a href=&#34;https://cuelang.org/docs/references/spec/#structs&#34;&gt;pattern constraint&lt;/a&gt;.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;[string]: string&lt;br /&gt;
Is a &lt;a href=&#34;https://cuelang.org/docs/references/spec/#structs&#34;&gt;pattern constraint&lt;/a&gt;, denoted &lt;strong&gt;[pattern]: value&lt;/strong&gt;. In the example, The pattern MUST be a string and the value MUST also be a string.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The vet command validates data with schemas. We can test our schema with the following command. In case of success the command doesn&amp;rsquo;t reply anything.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cue vet simple.cue simple.json
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we replace strings with integer or list in the JSON file like below.&lt;/p&gt;

&lt;h4 id=&#34;simplefalse-json&#34;&gt;simpleFalse.json&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;maptest&amp;quot;: {
     &amp;quot;mytest1&amp;quot;: 1,
     &amp;quot;mytest2&amp;quot;: [&amp;quot;mystring2&amp;quot;,&amp;quot;mystring21&amp;quot;,&amp;quot;mystring31&amp;quot;]
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You will have the following messages&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;noyel@goku-srv:~/script/cue$ cue vet simple.cue simpleFalse.json
maptest.mytest1: conflicting values 1 and string (mismatched types int and string):
    ./simple.cue:2:14
    ./simple.cue:5:10
    ./simpleFalse.json:3:17
maptest.mytest2: conflicting values string and [&amp;quot;mystring2&amp;quot;,&amp;quot;mystring21&amp;quot;,&amp;quot;mystring31&amp;quot;] (mismatched types string and list):
    ./simple.cue:2:14
    ./simpleFalse.json:4:17
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One thing I want to point out is that if you do a typo in the &lt;a href=&#34;https://cuelang.org/docs/references/spec/#identifiers&#34;&gt;Identifier&lt;/a&gt; and then it doesn&amp;rsquo;t match any variable in the JSON file, you will the same output than if your test are correct (nothing).&lt;/p&gt;

&lt;h1 id=&#34;overall-validation&#34;&gt;Overall validation&lt;/h1&gt;

&lt;h4 id=&#34;json-file-1&#34;&gt;JSON file&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;subnets&amp;quot; : {
    &amp;quot;sub-primary&amp;quot;   : { &amp;quot;subnet&amp;quot; : [&amp;quot;10.0.0.0&amp;quot;,&amp;quot;10.0.1.0&amp;quot;], &amp;quot;mask&amp;quot; : 24, &amp;quot;router&amp;quot; : &amp;quot;rtr-primary&amp;quot;   },
    &amp;quot;sub-secondary&amp;quot; : { &amp;quot;subnet&amp;quot; : [&amp;quot;10.0.2.0&amp;quot;]           , &amp;quot;mask&amp;quot; : 24, &amp;quot;router&amp;quot; : &amp;quot;rtr-secondary&amp;quot; }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;cue-schema-1&#34;&gt;CUE Schema&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;import ( &amp;quot;net&amp;quot; )
#subnetstruct: {
  [=~&amp;quot;^sub-&amp;quot;]: { &amp;quot;subnet&amp;quot; : [...net.IPv4], &amp;quot;mask&amp;quot; : int &amp;amp; &amp;gt;= 24 &amp;amp; &amp;lt;= 32, &amp;quot;router&amp;quot; : =~&amp;quot;^rtr-&amp;quot;} 
}
subnets: #subnetstruct
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For the complete example, the identifier and struct are the same, the only difference is the pattern constraint.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The &lt;strong&gt;pattern&lt;/strong&gt; of the &lt;a href=&#34;https://cuelang.org/docs/references/spec/#structs&#34;&gt;pattern constraint&lt;/a&gt; is a regex. The string that matches the regex define the key of our map. The key MUST start with sub-&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;The &lt;strong&gt;value&lt;/strong&gt; of the &lt;a href=&#34;https://cuelang.org/docs/references/spec/#structs&#34;&gt;pattern constraint&lt;/a&gt; is a &lt;a href=&#34;https://cuelang.org/docs/references/spec/#structs&#34;&gt;struct&lt;/a&gt; with 3 fields.&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;&amp;ldquo;subnet&amp;rdquo; : a list of strings that represent a valid IPv4 address. The three dots &amp;hellip; represent an ellipsis, it allow to say &amp;ldquo;any number of IPv4&amp;rdquo;.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;mask&amp;rdquo; : an int greater or equal to 24 and lower or equal to 32.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;router&amp;rdquo; : a string that must start with rtr-&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://cuelang.org/docs/references/spec/#definitions-and-hidden-fields&#34;&gt;Referencing&lt;/a&gt; a definition should recursively close it. In theory it&amp;rsquo;s not possible to add more fields in the struct.
In our case, the pattern constraint being a regex, you can add as many fields that matches the regex that you want. The values must conform the constraints you&amp;rsquo;ve put.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;bonus-point-chat-gpt-d&#34;&gt;Bonus point, Chat GPT :D&lt;/h1&gt;

&lt;p&gt;I&amp;rsquo;ve asked Chat GPT to write a GO script that would transform my HCL into JSON. After multiple wrong responses and struggles, I&amp;rsquo;ve created a new session and it eventually found a working code.&lt;/p&gt;

&lt;h4 id=&#34;prompt&#34;&gt;Prompt&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;Could you write a GO code to transform the HCL below into JSON ?
        subnets = {
          &amp;quot;sub-primary&amp;quot;   = { &amp;quot;subnet&amp;quot; = [&amp;quot;10.0.0.0&amp;quot;,&amp;quot;10.0.1.0&amp;quot;], &amp;quot;mask&amp;quot;= 24, &amp;quot;router&amp;quot; = &amp;quot;rtr-primary&amp;quot;   },
          &amp;quot;sub-secondary&amp;quot; = { &amp;quot;subnet&amp;quot; = [&amp;quot;10.0.2.0&amp;quot;]           , &amp;quot;mask&amp;quot;= 24, &amp;quot;router&amp;quot; = &amp;quot;rtr-secondary&amp;quot; }
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;chat-gpt-go-code&#34;&gt;Chat GPT GO code&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
	&amp;quot;encoding/json&amp;quot;
	&amp;quot;fmt&amp;quot;

	&amp;quot;github.com/hashicorp/hcl&amp;quot;
)

func main() {
	hclStr := `
        subnets = {
          &amp;quot;sub-primary&amp;quot;   = { &amp;quot;subnet&amp;quot; = [&amp;quot;10.0.0.0&amp;quot;,&amp;quot;10.0.1.0&amp;quot;], &amp;quot;mask&amp;quot;= 24, &amp;quot;router&amp;quot; = &amp;quot;rtr-primary&amp;quot;   },
          &amp;quot;sub-secondary&amp;quot; = { &amp;quot;subnet&amp;quot; = [&amp;quot;10.0.2.0&amp;quot;]           , &amp;quot;mask&amp;quot;= 24, &amp;quot;router&amp;quot; = &amp;quot;rtr-secondary&amp;quot; }
        }
    `
	var data map[string]interface{}
	err := hcl.Decode(&amp;amp;data, hclStr)
	if err != nil {
		fmt.Println(err)
		return
	}

	jsonData, err := json.MarshalIndent(data, &amp;quot;&amp;quot;, &amp;quot;  &amp;quot;)
	if err != nil {
		fmt.Println(err)
		return
	}

	fmt.Println(string(jsonData))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;result-on-https-go-dev-play&#34;&gt;Result on &lt;a href=&#34;https://go.dev/play/&#34;&gt;https://go.dev/play/&lt;/a&gt;&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;subnets&amp;quot;: [
    {
      &amp;quot;sub-primary&amp;quot;: [
        {
          &amp;quot;mask&amp;quot;: 24,
          &amp;quot;router&amp;quot;: &amp;quot;rtr-primary&amp;quot;,
          &amp;quot;subnet&amp;quot;: [
            &amp;quot;10.0.0.0&amp;quot;,
            &amp;quot;10.0.1.0&amp;quot;
          ]
        }
      ],
      &amp;quot;sub-secondary&amp;quot;: [
        {
          &amp;quot;mask&amp;quot;: 24,
          &amp;quot;router&amp;quot;: &amp;quot;rtr-secondary&amp;quot;,
          &amp;quot;subnet&amp;quot;: [
            &amp;quot;10.0.2.0&amp;quot;
          ]
        }
      ]
    }
  ]
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>NSXT Service interface design consideration</title>
      <link>https://netmemo.github.io/post/nsxt-service-interface-design1/</link>
      <pubDate>Wed, 19 Oct 2022 19:15:38 +0200</pubDate>
      
      <guid>https://netmemo.github.io/post/nsxt-service-interface-design1/</guid>
      <description>

&lt;h1 id=&#34;original-design&#34;&gt;Original design&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;nsxt-svi-scenario0.png&#34;&gt; &lt;img src=&#34;nsxt-svi-scenario0.png&#34; alt=&#34;&#34; /&gt; &lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This is the starting point of the infrastructure. A classic design that lot of enterprises have or used to have.
Virtual Machine (VM) and Bare Metal Server (BMS) are sharing a same vlan behind a firewall.
Everything begins when the VM wants to move to a more virtual infrastructure with distributed routing and firewalling. In this case they want to move to VMware NSXT.&lt;/p&gt;

&lt;p&gt;From a physical point of view, the migration is performed on leaf and spine infrastructure that we will call the underlay.
Every firewall interface is a different security zone that we will call DMZ.
The aim of this blog post is to capture some thoughts around NSXT service interface design.&lt;/p&gt;

&lt;p&gt;- Minus sign is what I consider as a cons while writing this blog.&lt;br /&gt;
+ Plus sign is what I consider as a pros while writing this blog.&lt;/p&gt;

&lt;p&gt;There is no perfect solution, it always depends on the context and I might miss things so we can always discuss.&lt;br /&gt;
Some behavior that I currently consider as a cons can be a pros for the reader. This blog is really to capture what can be taken into consideration during the design phase and evaluate A couple of possible design scenarios.&lt;/p&gt;

&lt;h1 id=&#34;scenarios&#34;&gt;Scenarios&lt;/h1&gt;

&lt;h3 id=&#34;scenario-1-split-dmz-multi-dmz&#34;&gt;Scenario 1 : Split DMZ / Multi DMZ&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;nsxt-svi-scenario1.png&#34;&gt; &lt;img src=&#34;nsxt-svi-scenario1.png&#34; alt=&#34;&#34; /&gt; &lt;/a&gt;&lt;/p&gt;

&lt;p&gt;In this scenario we keep using the original firewall to protect the BMS and move all the virtual environment behind a new firewall interface creating a new DMZ&lt;/p&gt;

&lt;p&gt;- Need to create new subnet for VMs.&lt;br /&gt;
- Need to have groups with /32 host in the firewall rules to avoid breaking the orignal flow between BMS and VMs.&lt;br /&gt;
- More rules, bandwidth and sessions than before on physical FW (because the original DMZ is now splited).&lt;br /&gt;
- BMS to VM traffic need to go through Edge + FW.&lt;br /&gt;
- Possibility to create a single segment for all VMs. Not necessarily a good &lt;a href=&#34;https://netmemo.github.io/post/subnets-size-mix/&#34;&gt;idea&lt;/a&gt;.&lt;br /&gt;
+ We don&amp;rsquo;t touch BMS server, only VMs are impacted with this transformation.&lt;br /&gt;
+ Traffic from BMS to outside have to go only through FW compared to scenario 3.&lt;br /&gt;
+ No need of L3 interconnection with the underlay switch fabric like in scenario 2.&lt;/p&gt;

&lt;h3 id=&#34;scenario-2-one-vrf-per-firewall-interface&#34;&gt;Scenario 2 : One VRF per firewall interface.&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;nsxt-svi-scenario2.png&#34;&gt; &lt;img src=&#34;nsxt-svi-scenario2.png&#34; alt=&#34;&#34; /&gt; &lt;/a&gt;&lt;/p&gt;

&lt;p&gt;In this scenario we create a VRF in the underlay to attach the original subnet and the new virtual environnement.
We are not creating a new DMZ (firewall interface) and we can benefit the microsegmentation of NSXT between the VMs vlan with mixed application or tier (&lt;a href=&#34;https://netmemo.github.io/post/subnets-size-mix/&#34;&gt;link&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;- As many VRF as firewall interfaces (DMZ).&lt;br /&gt;
- Need to migrate the vlan attached to the firewall interface to the VRF.&lt;br /&gt;
- More configuration on the underlay switch fabric (L3 Configuration).&lt;br /&gt;
- We can&amp;rsquo;t merge all VM behind a single DMZ (single segment for all VMs).&lt;br /&gt;
- Need to create new subnets for VMs.&lt;br /&gt;
+ Distributed routing for VMs.&lt;br /&gt;
+ Microsegmentation between VMs of the same DMZ.&lt;br /&gt;
+ We keep the same security zone, firewall rules on perimeter firewall don&amp;rsquo;t need to change.&lt;br /&gt;
+ Less hop than scenario 1 between BMS and VM.&lt;br /&gt;
+ Less hop than scenario 3 between BMS and OUT.&lt;/p&gt;

&lt;h3 id=&#34;scenario-3-service-interface&#34;&gt;Scenario 3 : Service interface&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;nsxt-svi-scenario3.png&#34;&gt; &lt;img src=&#34;nsxt-svi-scenario3.png&#34; alt=&#34;&#34; /&gt; &lt;/a&gt;&lt;/p&gt;

&lt;p&gt;In this scenario we are using NSXT service interface to manage everything into NSXT. The aim is to have a single interface for Firewall rules (The NSXT Manager).&lt;/p&gt;

&lt;p&gt;- Firewall rules migration to gateway FW can be challenging.&lt;br /&gt;
- EdgeCluster is Active/Passive (no ECMP).&lt;br /&gt;
- Need more dedicated edge cluster to load shared traffic.&lt;br /&gt;
- More latency for BMS to exit the security zone than before move. (Edge + FW)&lt;br /&gt;
- Need to migrate the original DMZ to the edge cluster.&lt;br /&gt;
- Need to create new subnet for VMs.&lt;br /&gt;
- Possibility to create a single segment for all VMs. Not necessarily a good &lt;a href=&#34;https://netmemo.github.io/post/subnets-size-mix/&#34;&gt;idea&lt;/a&gt;.&lt;br /&gt;
+ Perimeter firewall can be removed or kept for N/S traffic only.&lt;br /&gt;
+ The security zones stay in NSX. If the perimeter firewall is kept, a single interface is needed.&lt;br /&gt;
+ Full NSX =&amp;gt; no L3 with underlay, same portal for firewall rules.&lt;br /&gt;
+ The traffic between BMS and VM has less latency than in scenario 2.&lt;br /&gt;
+ Less VRF than scenario 3.&lt;/p&gt;

&lt;h3 id=&#34;scenario-4-edge-bridge&#34;&gt;Scenario 4 : Edge Bridge&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;nsxt-svi-scenario4.png&#34;&gt; &lt;img src=&#34;nsxt-svi-scenario4.png&#34; alt=&#34;&#34; /&gt; &lt;/a&gt;&lt;/p&gt;

&lt;p&gt;- Not recommended because L2 is streched.&lt;br /&gt;
- Risks of instability.&lt;br /&gt;
- BMS to exit the DMZ need to go through at least two NSX Edges.&lt;br /&gt;
+ Can keep the same subnet between VM and BMS.&lt;br /&gt;
+ Can use microsegmentation between VMs.&lt;/p&gt;

&lt;h1 id=&#34;traffic-consideration&#34;&gt;Traffic consideration&lt;/h1&gt;

&lt;p&gt;The diagram below can highlight some traffic pattern to help understanding the challenges of some design scenarios. This is not an exhaustive diagram it only helps at the beginning of the design phase.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;nsxt-svi-physical.png&#34;&gt; &lt;img src=&#34;nsxt-svi-physical.png&#34; alt=&#34;&#34; /&gt; &lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Terraform list of map ordering</title>
      <link>https://netmemo.github.io/post/tf-map-ordering/</link>
      <pubDate>Sun, 24 Jul 2022 18:44:36 +0200</pubDate>
      
      <guid>https://netmemo.github.io/post/tf-map-ordering/</guid>
      <description>

&lt;h1 id=&#34;the-need&#34;&gt;The need&lt;/h1&gt;

&lt;p&gt;I went into some troubles when I wanted to implement NSXT rules. My aim was to keep the order of the rules as intended by the user when he wrote his data &lt;strong&gt;without asking him to enter a rule ID manually&lt;/strong&gt;. If the order is kept then it&amp;rsquo;s easy to prioritize the rules according to their placement.
With the &lt;a href=&#34;https://registry.terraform.io/providers/vmware/nsxt/latest/docs/resources/policy_security_policy&#34;&gt;NSX-T Terraform provider&lt;/a&gt; the rules are in the form below :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;resource &amp;quot;nsxt_policy_security_policy&amp;quot; &amp;quot;policy1&amp;quot; {
  display_name = &amp;quot;policy1&amp;quot;
  rule {
    ...
  }
  rule {
    ....
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can see that it&amp;rsquo;s made of &lt;strong&gt;rule&lt;/strong&gt; blocks. These blocks will be generated dynamically. We need a way to always have the same order while generating the rule blocks. If we don&amp;rsquo;t keep the order, Terraform complains that the rule has changed.
Every time we will add a rule they will be scrambled and Terraform will modify the order.&lt;/p&gt;

&lt;h1 id=&#34;why-does-this-happen&#34;&gt;Why does this happen ?&lt;/h1&gt;

&lt;p&gt;The data model I use to represent the rules is a list of map. Every map is a rule. We can sum up the data structure as below :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;listOfRule = [
  {
    display_name = &amp;quot;ruleA&amp;quot;
    source_groups   = &amp;quot;10.0.0.1&amp;quot;
    destination_groups   = &amp;quot;10.0.0.2&amp;quot;
  },
  {
    display_name = &amp;quot;ruleD&amp;quot;
    source_groups   = &amp;quot;10.1.0.1&amp;quot;
    destination_groups   = &amp;quot;10.1.0.2&amp;quot;
  }
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To understand the behavior, we will simplify this data structure to an object with 2 attributes. id which is an integer and name which is a string.
In this example, the ids are not sorted neither the names.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;variable &amp;quot;listOfRule&amp;quot; {
  default = [
    {
      id   = 3
      name = &amp;quot;ruleA&amp;quot;
    },
    {
      id   = 2
      name = &amp;quot;ruleD&amp;quot;
    },
    {
      id   = 10
      name = &amp;quot;ruleB&amp;quot;
    },
    {
      id   = 1
      name = &amp;quot;ruleC&amp;quot;
    }
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://www.terraform.io/language/meta-arguments/for_each&#34;&gt;for_each&lt;/a&gt; only accept a set or a map. When you have a list and you want to iterate it over a for_each, you need to either transform it into a &lt;a href=&#34;https://www.terraform.io/language/expressions/type-constraints#set&#34;&gt;set&lt;/a&gt; with the &lt;a href=&#34;https://www.terraform.io/language/functions/toset&#34;&gt;toset()&lt;/a&gt; function or create a map with a key thanks to the for loop.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{ for key, value in var.myvar : key =&amp;gt; value }
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;When transforming this list of object into a set, the order is not kept and is difficult to predict.&lt;/li&gt;
&lt;li&gt;When transforming this list of object into a map, the map will be sorted according to the key which &lt;strong&gt;MUST&lt;/strong&gt; be a string. The ordering is then done alphabetically.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To illustrate the ordering we will do different examples. You can copy the original variable in a main.tf file then play with it thanks to the &amp;ldquo;terraform console&amp;rdquo; command.&lt;/p&gt;

&lt;h1 id=&#34;the-examples&#34;&gt;The examples&lt;/h1&gt;

&lt;h3 id=&#34;transform-list-into-set&#34;&gt;Transform list into set&lt;/h3&gt;

&lt;p&gt;With this transformation we see that the order is not easy to predict. In that case, it&amp;rsquo;s sorted numerically but with the longest id first.&lt;/p&gt;

&lt;table&gt;
&lt;tr&gt;
&lt;td&gt; Original &lt;/td&gt; &lt;td&gt; Sorted &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; 

&lt;pre&gt;
&lt;code&gt;
variable &#34;listOfRule&#34; {
  default = [
    {
      id   = 3
      name = &#34;ruleA&#34;
    },
    {
      id   = 2
      name = &#34;ruleD&#34;
    },
    {
      id   = 10
      name = &#34;ruleB&#34;
    },
    {
      id   = 1
      name = &#34;ruleC&#34;
    }
  ]
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;/td&gt;

&lt;td&gt;
&lt;pre&gt;
&lt;code&gt;
&gt; toset(var.listOfRule)
toset([
  {
    &#34;id&#34; = 10
    &#34;name&#34; = &#34;ruleB&#34;
  },
  {
    &#34;id&#34; = 1
    &#34;name&#34; = &#34;ruleC&#34;
  },
  {
    &#34;id&#34; = 2
    &#34;name&#34; = &#34;ruleD&#34;
  },
  {
    &#34;id&#34; = 3
    &#34;name&#34; = &#34;ruleA&#34;
  },
])

&lt;/code&gt;
&lt;/pre&gt;
&lt;/td&gt;

&lt;/tr&gt;
&lt;/table&gt;

&lt;h3 id=&#34;transform-list-into-map-with-name-as-index&#34;&gt;Transform list into map with name as index&lt;/h3&gt;

&lt;p&gt;Here this is sorted alphabetically.&lt;/p&gt;

&lt;table&gt;
&lt;tr&gt;
&lt;td&gt; Original &lt;/td&gt; &lt;td&gt; Sorted &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; 

&lt;pre&gt;
&lt;code&gt;
variable &#34;listOfRule&#34; {
  default = [
    {
      id   = 3
      name = &#34;ruleA&#34;
    },
    {
      id   = 2
      name = &#34;ruleD&#34;
    },
    {
      id   = 10
      name = &#34;ruleB&#34;
    },
    {
      id   = 1
      name = &#34;ruleC&#34;
    }
  ]
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;/td&gt;

&lt;td&gt;
&lt;pre&gt;
&lt;code&gt;
&gt; { for key,rule in var.listOfRule : rule.name =&gt; rule }
{
  &#34;ruleA&#34; = {
    &#34;id&#34; = 3
    &#34;name&#34; = &#34;ruleA&#34;
  }
  &#34;ruleB&#34; = {
    &#34;id&#34; = 10
    &#34;name&#34; = &#34;ruleB&#34;
  }
  &#34;ruleC&#34; = {
    &#34;id&#34; = 1
    &#34;name&#34; = &#34;ruleC&#34;
  }
  &#34;ruleD&#34; = {
    &#34;id&#34; = 2
    &#34;name&#34; = &#34;ruleD&#34;
  }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;/td&gt;

&lt;/tr&gt;
&lt;/table&gt;

&lt;h3 id=&#34;transform-list-into-a-map-with-id-as-index&#34;&gt;Transform list into a map with id as index&lt;/h3&gt;

&lt;p&gt;Here the numerical index is transformed into a string and then it&amp;rsquo;s sorted alphabetically. 10 is before 2 because 1 is bigger than 2.&lt;/p&gt;

&lt;table&gt;
&lt;tr&gt;
&lt;td&gt; Original &lt;/td&gt; &lt;td&gt; Sorted &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; 

&lt;pre&gt;
&lt;code&gt;
variable &#34;listOfRule&#34; {
  default = [
    {
      id   = 3
      name = &#34;ruleA&#34;
    },
    {
      id   = 2
      name = &#34;ruleD&#34;
    },
    {
      id   = 10
      name = &#34;ruleB&#34;
    },
    {
      id   = 1
      name = &#34;ruleC&#34;
    }
  ]
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;/td&gt;

&lt;td&gt;
&lt;pre&gt;
&lt;code&gt;
&gt; { for key,rule in var.listOfRule : rule.id =&gt; rule }
{
  &#34;1&#34; = {
    &#34;id&#34; = 1
    &#34;name&#34; = &#34;ruleC&#34;
  }
  &#34;10&#34; = {
    &#34;id&#34; = 10
    &#34;name&#34; = &#34;ruleB&#34;
  }
  &#34;2&#34; = {
    &#34;id&#34; = 2
    &#34;name&#34; = &#34;ruleD&#34;
  }
  &#34;3&#34; = {
    &#34;id&#34; = 3
    &#34;name&#34; = &#34;ruleA&#34;
  }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;/td&gt;

&lt;/tr&gt;
&lt;/table&gt;

&lt;h3 id=&#34;transform-list-into-a-map-using-the-list-key-as-index&#34;&gt;Transform list into a map using the list key as index.&lt;/h3&gt;

&lt;p&gt;With a list, there is an implicit numerical index starting from 0. We can try to use this index as a key for the map.&lt;/p&gt;

&lt;table&gt;
&lt;tr&gt;
&lt;td&gt; Original &lt;/td&gt; &lt;td&gt; Sorted &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; 
&lt;pre&gt;
&lt;code&gt;
variable &#34;listOfRule&#34; {
  default = [
    {
      id   = 3
      name = &#34;ruleA&#34;
    },
    {
      id   = 2
      name = &#34;ruleD&#34;
    },
    {
      id   = 10
      name = &#34;ruleB&#34;
    },
    {
      id   = 1
      name = &#34;ruleC&#34;
    }
  ]
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;/td&gt;

&lt;td&gt;
&lt;pre&gt;
&lt;code&gt;
&gt; { for key,rule in var.listOfRule : key =&gt; rule }
{
  &#34;0&#34; = {
    &#34;id&#34; = 3
    &#34;name&#34; = &#34;ruleA&#34;
  }
  &#34;1&#34; = {
    &#34;id&#34; = 2
    &#34;name&#34; = &#34;ruleD&#34;
  }
  &#34;2&#34; = {
    &#34;id&#34; = 10
    &#34;name&#34; = &#34;ruleB&#34;
  }
  &#34;3&#34; = {
    &#34;id&#34; = 1
    &#34;name&#34; = &#34;ruleC&#34;
  }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;/td&gt;

&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;That looks good until we start to have more than 10 values. for_each accept only string as index. When we use the numerical list index as key for the map it&amp;rsquo;s automatically transformed into a string. If we have more than 10 values, the index 10 is then put before 2. The reason is because when it&amp;rsquo;s sorted alphabetically, the first character is compared first and this is independent of the length of the string.&lt;/p&gt;

&lt;table&gt;
&lt;tr&gt;
&lt;td&gt; Original &lt;/td&gt; &lt;td&gt; Sorted &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; 

&lt;pre&gt;
&lt;code&gt;
variable &#34;listOfRule&#34; {
  default = [
    {
      &#34;id&#34; = 3
      &#34;name&#34; = &#34;ruleA&#34;
    },
    {
      &#34;id&#34; = 2
      &#34;name&#34; = &#34;ruleD&#34;
    },
    {
      &#34;id&#34; = 10
      &#34;name&#34; = &#34;ruleB&#34;
    },
    {
      &#34;id&#34; = 1
      &#34;name&#34; = &#34;ruleC&#34;
    },
    {
      &#34;id&#34; = 4
      &#34;name&#34; = &#34;ruleE&#34;
    },
    {
      &#34;id&#34; = 5
      &#34;name&#34; = &#34;ruleF&#34;
    },
    {
      &#34;id&#34; = 6
      &#34;name&#34; = &#34;ruleG&#34;
    },
    {
      &#34;id&#34; = 7
      &#34;name&#34; = &#34;ruleH&#34;
    },
    {
      &#34;id&#34; = 8
      &#34;name&#34; = &#34;ruleI&#34;
    },
    {
      &#34;id&#34; = 9
      &#34;name&#34; = &#34;ruleJ&#34;
    },
    {
      &#34;id&#34; = 20
      &#34;name&#34; = &#34;ruleK&#34;
    }
  ]
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;/td&gt;

&lt;td&gt;
&lt;pre&gt;
&lt;code&gt;
&gt; { for key,rule in var.listOfRule : key =&gt; rule }
{
  &#34;0&#34; = {
    &#34;id&#34; = 3
    &#34;name&#34; = &#34;ruleA&#34;
  }
  &#34;1&#34; = {
    &#34;id&#34; = 2
    &#34;name&#34; = &#34;ruleD&#34;
  }
  &#34;10&#34; = {
    &#34;id&#34; = 20
    &#34;name&#34; = &#34;ruleK&#34;
  }
  &#34;2&#34; = {
    &#34;id&#34; = 10
    &#34;name&#34; = &#34;ruleB&#34;
  }
  &#34;3&#34; = {
    &#34;id&#34; = 1
    &#34;name&#34; = &#34;ruleC&#34;
  }
  &#34;4&#34; = {
    &#34;id&#34; = 4
    &#34;name&#34; = &#34;ruleE&#34;
  }
  &#34;5&#34; = {
    &#34;id&#34; = 5
    &#34;name&#34; = &#34;ruleF&#34;
  }
  &#34;6&#34; = {
    &#34;id&#34; = 6
    &#34;name&#34; = &#34;ruleG&#34;
  }
  &#34;7&#34; = {
    &#34;id&#34; = 7
    &#34;name&#34; = &#34;ruleH&#34;
  }
  &#34;8&#34; = {
    &#34;id&#34; = 8
    &#34;name&#34; = &#34;ruleI&#34;
  }
  &#34;9&#34; = {
    &#34;id&#34; = 9
    &#34;name&#34; = &#34;ruleJ&#34;
  }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;/td&gt;

&lt;/tr&gt;
&lt;/table&gt;

&lt;h3 id=&#34;transform-list-into-a-map-with-numerical-index-as-a-string&#34;&gt;Transform list into a map with numerical index as a string&lt;/h3&gt;

&lt;p&gt;As for_each accept only string as key we need to find a way to emulate the numerical ordering with strings. To do that we need to convert the integer into strings of the same length. This way, we add 0 in front of shorter integer, as 0 is lower than 1 we prevent the previous behavior and we have the intended result.
In my case I used the &lt;a href=&#34;https://www.terraform.io/language/functions/format&#34;&gt;format&lt;/a&gt; function and chose a 4 characters length.&lt;/p&gt;

&lt;table&gt;
&lt;tr&gt;
&lt;td&gt; Original &lt;/td&gt; &lt;td&gt; Sorted &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; 

&lt;pre&gt;
&lt;code&gt;
variable &#34;listOfRule&#34; {
  default = [
    {
      &#34;id&#34; = 3
      &#34;name&#34; = &#34;ruleA&#34;
    },
    {
      &#34;id&#34; = 2
      &#34;name&#34; = &#34;ruleD&#34;
    },
    {
      &#34;id&#34; = 10
      &#34;name&#34; = &#34;ruleB&#34;
    },
    {
      &#34;id&#34; = 1
      &#34;name&#34; = &#34;ruleC&#34;
    },
    {
      &#34;id&#34; = 4
      &#34;name&#34; = &#34;ruleE&#34;
    },
    {
      &#34;id&#34; = 5
      &#34;name&#34; = &#34;ruleF&#34;
    },
    {
      &#34;id&#34; = 6
      &#34;name&#34; = &#34;ruleG&#34;
    },
    {
      &#34;id&#34; = 7
      &#34;name&#34; = &#34;ruleH&#34;
    },
    {
      &#34;id&#34; = 8
      &#34;name&#34; = &#34;ruleI&#34;
    },
    {
      &#34;id&#34; = 9
      &#34;name&#34; = &#34;ruleJ&#34;
    },
    {
      &#34;id&#34; = 20
      &#34;name&#34; = &#34;ruleK&#34;
    }
  ]
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;/td&gt;

&lt;td&gt;
&lt;pre&gt;

&gt; { for key,rule in var.listOfRule : format(&#34;%.4d&#34;,key) =&gt; rule }
{
  &#34;0000&#34; = {
    &#34;id&#34; = 3
    &#34;name&#34; = &#34;ruleA&#34;
  }
  &#34;0001&#34; = {
    &#34;id&#34; = 2
    &#34;name&#34; = &#34;ruleD&#34;
  }
  &#34;0002&#34; = {
    &#34;id&#34; = 10
    &#34;name&#34; = &#34;ruleB&#34;
  }
  &#34;0003&#34; = {
    &#34;id&#34; = 1
    &#34;name&#34; = &#34;ruleC&#34;
  }
  &#34;0004&#34; = {
    &#34;id&#34; = 4
    &#34;name&#34; = &#34;ruleE&#34;
  }
  &#34;0005&#34; = {
    &#34;id&#34; = 5
    &#34;name&#34; = &#34;ruleF&#34;
  }
  &#34;0006&#34; = {
    &#34;id&#34; = 6
    &#34;name&#34; = &#34;ruleG&#34;
  }
  &#34;0007&#34; = {
    &#34;id&#34; = 7
    &#34;name&#34; = &#34;ruleH&#34;
  }
  &#34;0008&#34; = {
    &#34;id&#34; = 8
    &#34;name&#34; = &#34;ruleI&#34;
  }
  &#34;0009&#34; = {
    &#34;id&#34; = 9
    &#34;name&#34; = &#34;ruleJ&#34;
  }
  &#34;0010&#34; = {
    &#34;id&#34; = 20
    &#34;name&#34; = &#34;ruleK&#34;
  }
}



&lt;/pre&gt;
&lt;/td&gt;

&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;Finally we got what we wanted, the order of the rules exactly the same as intended by the user after giving the list to the for_each Meta-Argument.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Terraform and the chicken and egg problem</title>
      <link>https://netmemo.github.io/post/tf-chicken-egg/</link>
      <pubDate>Sun, 19 Jun 2022 09:03:41 +0200</pubDate>
      
      <guid>https://netmemo.github.io/post/tf-chicken-egg/</guid>
      <description>

&lt;h1 id=&#34;the-chicken-and-egg-problem&#34;&gt;The chicken and egg problem&lt;/h1&gt;

&lt;p&gt;I write a lot on Terraform because I like the tool very much. This time I thought it would be good to show a situation where Terraform is not necessarily the best tool for the job. The diagram below illustrates the problem.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;f5-tf-a-b.png&#34;&gt; &lt;img src=&#34;f5-tf-a-b.png&#34; alt=&#34;&#34; /&gt; &lt;/a&gt;&lt;/p&gt;

&lt;p&gt;A needs B and B needs A. If the relationship is mandatory it will be impossible to provision these resources because we have a chicken and egg problem.
However, in our example, if A doesn&amp;rsquo;t need B from the beginning, we can provision A then B and add the link to B afterwards.
The issue is then how do you do it in Terraform ? Once the resource A is provisonned, how do you add automatically the link to B ?&lt;/p&gt;

&lt;h1 id=&#34;the-example&#34;&gt;The example&lt;/h1&gt;

&lt;p&gt;To illustrate this, we will use F5 BIG-IP and the below diagram.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;f5-tf-light-bigip.png&#34;&gt; &lt;img src=&#34;f5-tf-light-bigip.png&#34; alt=&#34;&#34; /&gt; &lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;We want to create a route domain but it needs a vlan&lt;/li&gt;
&lt;li&gt;We want to create a vlan but it needs a partition&lt;/li&gt;
&lt;li&gt;We want to create a partition but it needs a route domain&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;What will help us in this case is that the route domain doesn&amp;rsquo;t require a vlan, we will be able to add the vlan to the route domain afterwards. The steps will be :&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Create a route domain&lt;/li&gt;
&lt;li&gt;Create a partition and associate it to a route domain&lt;/li&gt;
&lt;li&gt;Create a vlan and associate it to the partition&lt;/li&gt;
&lt;li&gt;Modify the route domain to add the vlan&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;We see that we need 4 steps and the last step is to modify the first resource.&lt;/p&gt;

&lt;h1 id=&#34;how-to-do-it-with-terraform&#34;&gt;How to do it with Terraform ?&lt;/h1&gt;

&lt;h3 id=&#34;manual-approach&#34;&gt;Manual approach&lt;/h3&gt;

&lt;p&gt;We can do it manually by changing the code and pushing a second time the configuration to production but it doesn&amp;rsquo;t seem to be the more efficient approach.&lt;/p&gt;

&lt;h3 id=&#34;the-workaround-approach&#34;&gt;The workaround approach&lt;/h3&gt;

&lt;p&gt;Currently with the bigip Terraform provider, the only resource available is the &amp;ldquo;bigip_net_vlan&amp;rdquo; resource. We can however use the &amp;ldquo;bigip_command&amp;rdquo; resource to simulate the missing resources but without keeping a real state. We also need to add the depends_on attribute if we want Terraform to respect the creation steps.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;f5-tf-bigip.png&#34;&gt; &lt;img src=&#34;f5-tf-bigip.png&#34; alt=&#34;&#34; /&gt; &lt;/a&gt;&lt;/p&gt;

&lt;p&gt;We see with this example that we need an extra resource/command to add the missing element in our first resource (step 4). In this example this is possible because we use a resource to simulate a manual action. With this approach we are not keeping a proper state of any infrastructure, we don&amp;rsquo;t really have dependencies and thus we lose the main benefit of the tool.&lt;/p&gt;

&lt;h3 id=&#34;the-new-resource-approach&#34;&gt;The new resource approach&lt;/h3&gt;

&lt;p&gt;Another option could be to develop a specific resource that takes care of the 4 steps needed to create the environment. This resource will take care of all the API call for the 3 components in the background but as the &lt;a href=&#34;https://www.terraform.io/plugin/hashicorp-provider-design-principles&#34;&gt;Provider Design Principles&lt;/a&gt; documentation states :&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A Terraform resource should be a declarative representation of single component&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;There is probably a reason for that. Having a single resource managing 3 components and their dependancies come with the associate complexity.&lt;/p&gt;

&lt;h1 id=&#34;netmemo-s-take&#34;&gt;Netmemo&amp;rsquo;s take&lt;/h1&gt;

&lt;p&gt;The purpose of this example was to illustrate a use case where Terraform is not necessarily the best tool for the job. Sometimes what we have to provision hasn&amp;rsquo;t be designed for a tool like Terraform. Thus it can be more complex to develop resources to manage it. In this kind of situation other tools where you can define steps or programming languages might be more suitable.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ACI Terraform scalability</title>
      <link>https://netmemo.github.io/post/aci-terraform-scale/</link>
      <pubDate>Wed, 18 May 2022 22:41:35 +0200</pubDate>
      
      <guid>https://netmemo.github.io/post/aci-terraform-scale/</guid>
      <description>

&lt;h1 id=&#34;the-context&#34;&gt;The context&lt;/h1&gt;

&lt;p&gt;This blog is to explains the scalability issue I have faced while trying to use Terraform to deploy Cisco ACI Fabric.
Terraform has been developed initially to deploy Cloud infrastructure. As everything is virtual in a Cloud environment, it&amp;rsquo;s more or less easy to organize your Terraform infrastructure per application to keep the environment small enough. As a best practice it&amp;rsquo;s recommended to keep the workspaces as small as possible to avoid performance issues. As Terraform works on a dependency graph, the more resources and dependencies you have, the longer it takes for Terraform to compute a plan and push the configuration.
To come back to the issue and give a little bit of context, let&amp;rsquo;s take the fabric below as an example.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The Cisco ACI fabric is in network centric mode (1 EPG = 1 BD = 1 vlan).&lt;/li&gt;
&lt;li&gt;The fabric has 6 leaves and 2 spines.&lt;/li&gt;
&lt;li&gt;Each leaf has 48 ports.&lt;/li&gt;
&lt;li&gt;32 ports are configured on each leaf to connect hypervisor.&lt;/li&gt;
&lt;li&gt;100 vlans are configured on each port.
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We are using a small Terraform Enterprise agent to push the configuration with 2G of RAM and 2vCPU.&lt;/p&gt;

&lt;h1 id=&#34;the-problem&#34;&gt;The problem&lt;/h1&gt;

&lt;p&gt;When provisioning ACI, 2 kind of resources need to be monitored carefully.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The number of resources tied to vlans because to create 1 vlan we need 3 resources

&lt;ul&gt;
&lt;li&gt;aci_application_epg&lt;/li&gt;
&lt;li&gt;aci_bridge_domain&lt;/li&gt;
&lt;li&gt;aci_epg_to_domain&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;The static path binding

&lt;ul&gt;
&lt;li&gt;aci_epg_to_static_path&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;resources-tied-to-vlans&#34;&gt;Resources tied to vlans&lt;/h3&gt;

&lt;p&gt;For the first kind of resources, if you have 300 vlans, you will end up with at least 900 resources. After you have deployed the fabric the increase in resources stays most of the time very slow and constant. Every new vlan is ~3 new resources and will not make a big difference straight away.&lt;/p&gt;

&lt;h3 id=&#34;static-path-binding&#34;&gt;Static path binding&lt;/h3&gt;

&lt;p&gt;The second kind of resource is much more problematic. You need one static path binding resource per vlan per port. In our case it would be 19200 resources and that&amp;rsquo;s a lot !!! (100 vlans x 32 ports x 6 leaves = 19200 static path binding resources).
In my case I&amp;rsquo;ve managed to pushed approximately 7000 resources and it was taking more than 1h to plan and 1h to apply with a Terraform Enterprise agent. Every time you will add a new server, unless you have a &lt;a href=&#34;https://kontrolissues.net/2015/03/27/sometimes-size-matters-im-sorry-but-youre-just-not-big-enough/&#34;&gt;single&lt;/a&gt; interface you will add at least 200 resources.&lt;/p&gt;

&lt;h1 id=&#34;the-workaround&#34;&gt;The workaround&lt;/h1&gt;

&lt;p&gt;What option do we have to overcome this major road block ?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The first option would be to throw more CPU and RAM on the agent and change the &lt;a href=&#34;https://www.terraform.io/cloud-docs/workspaces/variables&#34;&gt;parallelism&lt;/a&gt; option. I&amp;rsquo;ve tried to double the CPU and RAM on the server but the improvement wasn&amp;rsquo;t significative.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The second idea that comes to mind is to split the infrastructure into small workspaces but it&amp;rsquo;s very difficult when working with ACI in network centric approach. Even if you manage to split workspaces per business unit, your biggest business unit may have 100 vlans. Then, you can try to split your business unit per application but in the end, you probably don&amp;rsquo;t want to have the configuration of a single physical port split into 10+ workspaces.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The third option could be to use AAEP binding to EPG. For a green field deployment and if you don&amp;rsquo;t mind about the constraint&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; it would be the best approach. For a brown field deployment, it might be difficult to change your design and configuration of the production environment.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The forth option can be to not manage the static path binding through Terraform and use some other automation magic to take care of this bit with some CI/CD pipeline unicorn dust :D&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If I have missed something, you can contact me via linkedin or twitter.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;&lt;a href=&#34;https://www.cisco.com/c/en/us/td/docs/switches/datacenter/aci/apic/sw/2-x/L2_config/b_Cisco_APIC_Layer_2_Configuration_Guide/b_Cisco_APIC_Layer_2_Configuration_Guide_chapter_011.html&#34;&gt;EPG association&lt;/a&gt; with the AEP without static binding does not work in a scenario when you configure the EPG as Trunk under the AEP with one end point under the same EPG supporting Tagging and the other end point in the same EPG does not support VLAN tagging. While associating AEP under the EPG, you can configure it as Trunk, Access (Tagged) or Access (Untagged).
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;^&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>How to check a variable in a Hashicorp Sentinel policy</title>
      <link>https://netmemo.github.io/post/sentinel-variable-check/</link>
      <pubDate>Tue, 19 Apr 2022 09:08:48 +0200</pubDate>
      
      <guid>https://netmemo.github.io/post/sentinel-variable-check/</guid>
      <description>

&lt;p&gt;This blog is a minimalist example of a Hashicorp Sentinel policy to check the content of a string variable.
I&amp;rsquo;ve struggled a bit to write my first policy and had difficulties understanding the elements required. &lt;a href=&#34;https://nicovibert.com/2020/09/21/hashicorp-sentinel-policy-as-code/&#34;&gt;Nico Vibert&lt;/a&gt;&amp;rsquo;s blog has helped a lot.&lt;/p&gt;

&lt;p&gt;Hashicorps sentinel policy are policies as code that will allow you to control what users are pushing through Terraform Enterprise/Cloud. This is a paid feature, Open Policy Agent is the open source alternative.&lt;/p&gt;

&lt;p&gt;The use case in this example is to check a variable in a Terraform script that we don&amp;rsquo;t want the user to be able to modify.
Let&amp;rsquo;s say for instance that a variable named prefix is used to prefix all Terraform resources of an environment and we don&amp;rsquo;t want the user to be able to change it. The aim of this policy is to ensure that there is a variable &amp;ldquo;prefix&amp;rdquo; with the value &amp;ldquo;ABC&amp;rdquo; in the Terraform script. This is the equivalent of enforcing a variable to be in read only mode.&lt;/p&gt;

&lt;p&gt;As this is my first blog on Hashicorp Sentinel policy, I created a serie of 3 posts to also explain how I tested and pushed to production the policy :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../sentinel-variable-check/&#34;&gt;The policy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../hashicorp-sentinel-test/&#34;&gt;The test environment&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../hashicorp-sentinel-prod/&#34;&gt;The production environment&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;the-policy&#34;&gt;THE POLICY&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;import &amp;quot;tfplan/v2&amp;quot; as tfplan

#Get variable prefix
variablesPrefix = filter tfplan.variables as _, v {
    v.name is &amp;quot;prefix&amp;quot; and v.value is &amp;quot;ABC&amp;quot;
}

#This policy will be true if the variable &amp;quot;prefix&amp;quot; exist and its value is ABC
main = rule { length(variablesPrefix) is not 0 }
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The import &lt;a href=&#34;https://www.terraform.io/cloud-docs/sentinel/import/tfplan-v2&#34;&gt;tfplan/v2&lt;/a&gt; allows to get access to all the information of a plan.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Then the policy uses the &lt;a href=&#34;https://docs.hashicorp.com/sentinel/language/spec#quantifier-expressions-any-all-filter-map&#34;&gt;Quantifier&lt;/a&gt; Expression &lt;strong&gt;filter&lt;/strong&gt; to get all variables named &lt;strong&gt;prefix&lt;/strong&gt; with a value equal to &lt;strong&gt;ABC&lt;/strong&gt;.&lt;br /&gt;
Below you have the output of the &lt;strong&gt;variablesPrefix&lt;/strong&gt; after the filer has been applied and found the &lt;strong&gt;prefix&lt;/strong&gt; variable with the value &lt;strong&gt;ABC&lt;/strong&gt; :&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;Print messages:

{&amp;quot;prefix&amp;quot;: {&amp;quot;name&amp;quot;: &amp;quot;prefix&amp;quot;, &amp;quot;value&amp;quot;: &amp;quot;ABC&amp;quot;}}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;The last line is the main rule that must be true to pass the &lt;a href=&#34;https://docs.hashicorp.com/sentinel/concepts/enforcement-levels&#34;&gt;enforcement_level&lt;/a&gt;. According to the enforcement level, you will be able to apply the configuration. In this case, if the length of the result is 0 that means there is no &lt;strong&gt;prefix&lt;/strong&gt; variable with the value &lt;strong&gt;ABC&lt;/strong&gt; so the rule is not respected and the policy will fail.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>How to put in production a Hashicorp Sentinel policy</title>
      <link>https://netmemo.github.io/post/hashicorp-sentinel-prod/</link>
      <pubDate>Tue, 19 Apr 2022 09:08:32 +0200</pubDate>
      
      <guid>https://netmemo.github.io/post/hashicorp-sentinel-prod/</guid>
      <description>

&lt;p&gt;In this third and last post of the serie, I will describe how to move the Sentinel policy into the production environment.&lt;/p&gt;

&lt;p&gt;This serie is made of 3 posts:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../sentinel-variable-check/&#34;&gt;The policy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../hashicorp-sentinel-test/&#34;&gt;The test environment&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../hashicorp-sentinel-prod/&#34;&gt;The production environment&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;the-production-environment&#34;&gt;THE PRODUCTION ENVIRONMENT&lt;/h1&gt;

&lt;p&gt;When your policy is ready, you need to deploy it into production. You can write a policy set that you will store to a VCS (version control system) or you can add the policy individually in the GUI and attach it to the a policy set that you would have created on the GUI.&lt;/p&gt;

&lt;h3 id=&#34;vcs-policy-set&#34;&gt;VCS Policy set&lt;/h3&gt;

&lt;p&gt;For the VCS policy set, once you have created the policy, you need to create a repository on a VCS. In this repository you will have 2 kind of files. The policies with the &lt;strong&gt;.sentinel&lt;/strong&gt; extension and the configuration file &lt;strong&gt;sentinel.hcl&lt;/strong&gt;.
In the .hcl you only need to specify the source file that will define the policy and the &lt;a href=&#34;https://docs.hashicorp.com/sentinel/concepts/enforcement-levels&#34;&gt;enforcement_level&lt;/a&gt;. As hard-mandatory is the default enforcement level we can even omit it.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;policy &amp;quot;first_pol&amp;quot; {
  source = &amp;quot;./first_pol.sentinel&amp;quot;
  enforcement_level = &amp;quot;hard-mandatory&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The repository will look like :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.
├── first_pol.sentinel
└── sentinel.hcl
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;gui-policy-set-and-policy&#34;&gt;GUI policy set and policy&lt;/h3&gt;

&lt;p&gt;If you don&amp;rsquo;t want to use a VCS, you need to create the policy set and the policy through the GUI. Follow the below steps.&lt;/p&gt;

&lt;p&gt;&lt;details&gt;
&lt;summary&gt;1. Create the policy set&lt;/summary&gt;
Create the policy set and attach it the the right workspace, in our case netmemo-sentinel&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;connect-pol-set.png&#34;&gt; &lt;img src=&#34;connect-pol-set.png&#34; alt=&#34;&#34; /&gt; &lt;/a&gt;
&lt;a href=&#34;connect-pol-set-2.png&#34;&gt; &lt;img src=&#34;connect-pol-set-2.png&#34; alt=&#34;&#34; /&gt; &lt;/a&gt;
&lt;/details&gt;&lt;/p&gt;

&lt;p&gt;&lt;details&gt;
&lt;summary&gt;2. Create the policy&lt;/summary&gt;
Create the policy and attach it the the right policy set, in our case netmemo-policy-set
&lt;a href=&#34;create-new-policy-2.png&#34;&gt; &lt;img src=&#34;create-new-policy-2.png&#34; alt=&#34;&#34; /&gt; &lt;/a&gt;
&lt;/details&gt;&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Once the policy is ready, you can plan the Terraform configuration.
If the policy passes you should have the below output&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;snip&amp;gt;
------------------------------------------------------------------------

Organization policy check:

================ Results for policy set: &amp;lt;empty policy set name&amp;gt; ===============

Sentinel Result: true

This result means that all Sentinel policies passed and the protected
behavior is allowed.

1 policies evaluated.

## Policy 1: stringCheck (hard-mandatory)

Result: true

./stringCheck.sentinel:9:1 - Rule &amp;quot;main&amp;quot;
  Description:
    This policy will be true if the variable &amp;quot;prefix&amp;quot; exist and its
    value is ABC

  Value:
    true

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the policy fails you should have the below output&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;snip&amp;gt;
------------------------------------------------------------------------

Organization policy check:

================ Results for policy set: &amp;lt;empty policy set name&amp;gt; ===============

Sentinel Result: false

This result means that one or more Sentinel policies failed. More than likely,
this was due to the discovery of violations by the main rule and other
sub-rules. Please see the details of the policies executed below to find the
violation(s), which is usually indicated by a rule with a false boolean value,
or non-zero collection data.

1 policies evaluated.

## Policy 1: stringCheck (hard-mandatory)

Result: false

./stringCheck.sentinel:9:1 - Rule &amp;quot;main&amp;quot;
  Description:
    This policy will be true if the variable &amp;quot;prefix&amp;quot; exist and its
    value is ABC

  Value:
    false


╷
│ Error: Organization policy check hard failed.
│ 
│ 
╵
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>How to test a Hashicorp Sentinel policy</title>
      <link>https://netmemo.github.io/post/hashicorp-sentinel-test/</link>
      <pubDate>Tue, 19 Apr 2022 09:08:28 +0200</pubDate>
      
      <guid>https://netmemo.github.io/post/hashicorp-sentinel-test/</guid>
      <description>

&lt;p&gt;In this second post of the serie, I will describe the steps I have done to set up the test environment to test my Sentinel policy.&lt;/p&gt;

&lt;p&gt;This serie is made of 3 posts:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../sentinel-variable-check/&#34;&gt;The policy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../hashicorp-sentinel-test/&#34;&gt;The test environment&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../hashicorp-sentinel-prod/&#34;&gt;The production environment&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;the-test-environment&#34;&gt;THE TEST ENVIRONMENT&lt;/h1&gt;

&lt;p&gt;When we develop the policy it will be very difficult to push a configuration to see if the policy behaves like we want. Hashicorp provide a test environment to ease the development of the policies.&lt;/p&gt;

&lt;h3 id=&#34;test-environment-setup-steps&#34;&gt;Test environment setup steps&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://learn.hashicorp.com/tutorials/terraform/sentinel-install?in=terraform/policy&#34;&gt;Install&lt;/a&gt; sentinel policy CLI&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Download the mock file that will feed our test environment :
&lt;details&gt;
&lt;summary&gt;Click on &amp;ldquo;Download Sentinel mocks&amp;rdquo;&lt;/summary&gt;
&lt;a href=&#34;downloadSentinelPolicy.png&#34;&gt; &lt;img src=&#34;downloadSentinelPolicy.png&#34; alt=&#34;&#34; /&gt; &lt;/a&gt;
&lt;/details&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Unzip the file.&lt;br /&gt;
We will have all the possible environments of a Terraform Enterprise/Cloud mocked in files. In our case, as we will only use the tfplan/v2, the only file that is relevant is &lt;strong&gt;mock-tfplan-v2.sentinel&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Create test scenario.&lt;br /&gt;
The folder structure MUST be /test/&amp;lt;policy&amp;gt;/*.hcl.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;test is the parent directory of the tests.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&amp;lt;policy&amp;gt; must match the tested policy name.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;.hcl is the test scenario file.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Move the mocked data into the directory after the test file structure has been created. In our case we move the &lt;strong&gt;mock-tfplan-v2.sentinel&lt;/strong&gt; file that we had unziped previously. The final directory and file structure should be like below.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;.
├── first_pol.sentinel
└── test
    └── first_pol
        ├── mock-tfplan-v2.sentinel
        └── mypasstest.hcl
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;test-file-scenario&#34;&gt;Test file scenario&lt;/h3&gt;

&lt;p&gt;In the hcl test file, you will have 2 blocks.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The mock block that refer to the file that cater the data for the test scenario.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;the test block that will represent the conditions to pass the test.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In our case it will be&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mock &amp;quot;tfplan/v2&amp;quot; {
  module {
    source = &amp;quot;mock-tfplan-v2.sentinel&amp;quot;
  }
}

test {
    rules = {
        main = true
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The we can issue the command &lt;strong&gt;sentinel test&lt;/strong&gt; to test our policy&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sentinel test
PASS - first_pol.sentinel
  PASS - test/first_pol/mypasstest.hcl
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;fail-test-scenario&#34;&gt;Fail test scenario&lt;/h3&gt;

&lt;p&gt;If we want to go a step further, in software world it&amp;rsquo;s a common practice to write failed test case scenario. It ensures your software is able to handle failure and that there are no regression when you iterate your code.&lt;/p&gt;

&lt;p&gt;In such case, you also need to create a fail test scenario file such /test/&amp;lt;policy&amp;gt;/myfailtest.hcl with the failing condition and the mocked data with the data that will ensure the test will fail.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What can cause confusion is that this test case should PASS if your test FAIL because you are expecting it to fail.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The test plan will look like as below with the main rule equal to &lt;strong&gt;false&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mock &amp;quot;tfplan/v2&amp;quot; {
  module {
    source = &amp;quot;mock-tfplan-v2-fail.sentinel&amp;quot;
  }
}

test {
    rules = {
        main = false
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we need to modify the mocked data to fail the policy and so PASS the test. For our example we change the value from ABC to DEF.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;variables = {
	&amp;quot;prefix&amp;quot;: {
		&amp;quot;name&amp;quot;:  &amp;quot;prefix&amp;quot;,
		&amp;quot;value&amp;quot;: &amp;quot;DEF&amp;quot;,
	},
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The file structure will look like below.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.
├── first_pol.sentinel
└── test
    └── first_pol
        ├── mock-tfplan-v2-fail.sentinel
        ├── mock-tfplan-v2.sentinel
        ├── myfailtest.hcl
        └── mypasstest.hcl
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally we can test our policy again.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sentinel test
PASS - first_pol.sentinel
  PASS - test/first_pol/myfailtest.hcl
  PASS - test/first_pol/mypasstest.hcl
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>NSX-T Uplinks Memo</title>
      <link>https://netmemo.github.io/post/nsx-t-uplinks-memo/</link>
      <pubDate>Tue, 15 Mar 2022 19:17:50 +0100</pubDate>
      
      <guid>https://netmemo.github.io/post/nsx-t-uplinks-memo/</guid>
      <description>

&lt;p&gt;This is a memo regarding NSX-T uplinks. I think this is the most confusing and difficult part to understand in NSX-T.
This post is made of 3 sections, &lt;strong&gt;Diagram&lt;/strong&gt; with a more visual approach, &lt;strong&gt;Component&lt;/strong&gt; with remarks/comments on uplinks components and a &lt;strong&gt;Q&amp;amp;A&lt;/strong&gt; section based on questions I was asking myself. You can find duplicate information but slightly rephrased in every section. I kept it that way as some time some form are easier to understand than other. If you spot errors don&amp;rsquo;t hesitate to contact me.&lt;/p&gt;

&lt;h1 id=&#34;diagram&#34;&gt;Diagram&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;nvds-vs-vds7.png&#34;&gt; &lt;img src=&#34;nvds-vs-vds7.png&#34; alt=&#34;&#34; /&gt; &lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;legend&#34;&gt;Legend&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;Switch port trunk (vlan id of vteps + uplinks)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Prior to vDS7, physical interfaces are exclusive to NVDS or vDS.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;The association is done when the host is configured for NSX-T then the &lt;strong&gt;uplink profile&lt;/strong&gt; is associated to the transport node.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;If you want to use the same physical interfaces as the default profile, the uplink name on the named teaming policy has to be identical.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;If you put 2 active interfaces in your named teaming policy you lose the benefit of having deterministic uplink for you Edge/T0 uplinks. If you put active/standby interface here, you can&amp;rsquo;t have active/active interfaces in the default teaming policy.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;This Edge VM interface is attached through vcenter to the NSX-T Switch or vDS7 port group. This is like the interface of the host connected to the physical switch in the first point.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Uplink to interface mapping is done when the &lt;strong&gt;uplink profile&lt;/strong&gt; association to the transport node is done.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;If we add a second standby uplink in the &lt;strong&gt;Named Teaming Policy&lt;/strong&gt;, it impact the default teaming policy. You will not be able to have the 2 uplinks active at the same time. It&amp;rsquo;s those better to have a single uplink in the &lt;strong&gt;Named Teaming Policy&lt;/strong&gt; if you want to have active/active links in the default teaming policy. &lt;strong&gt;Named Teaming Policy&lt;/strong&gt; are available only for segment of type vlan. See also point 5.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;In the &lt;strong&gt;Transport Zone&lt;/strong&gt;, any &lt;strong&gt;Named Teaming Policy&lt;/strong&gt; from any &lt;strong&gt;Uplink Profile&lt;/strong&gt; can be selected. On the segment vlan, any &lt;strong&gt;Named Teaming Policy&lt;/strong&gt; associated with the TZ can be chosen. The issue being that if the &lt;strong&gt;Segment Vlan&lt;/strong&gt; is then used on a &lt;strong&gt;Transport Node&lt;/strong&gt; with an &lt;strong&gt;Uplink Profile&lt;/strong&gt; which don&amp;rsquo;t have the &lt;strong&gt;Named Teaming Policy&lt;/strong&gt; defined it will not works. NSX-T doesn&amp;rsquo;t see any error. Also you never know if the &lt;strong&gt;Named Teaming Policy&lt;/strong&gt; defined in an &lt;strong&gt;Uplink Profile&lt;/strong&gt; are used.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Default behavior if we don&amp;rsquo;t want any specific behavior for the uplinks.&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;components&#34;&gt;Components&lt;/h1&gt;

&lt;h3 id=&#34;location-nsx-t-3-1&#34;&gt;Location (NSX-T 3.1)&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;System -&amp;gt; Fabric -&amp;gt; Profiles -&amp;gt; Uplink Profile  
   - Transport VLAN  
   - MTU  
   - LAG  
   - Teamings  
      - Default Teaming -&amp;gt; Uplink  
      - Add -&amp;gt; Named (Named teaming policy) -&amp;gt; Uplink  

System -&amp;gt; Fabric -&amp;gt; Transport Zone  
  - Named teaming policy  

System -&amp;gt; Nodes  
  - hostswitch name/vds name  
  - Transport Zone  
  - Uplink profile  
     - Uplink -&amp;gt; physical nic  

Networking -&amp;gt; Segment  
   - Transport Zone (vlan or overlay)  
   - Uplink Teaming Policy (Named teaming policy only for TZ Vlan)  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;remarks&#34;&gt;Remarks&lt;/h3&gt;

&lt;p&gt;&lt;u&gt;&lt;strong&gt;Uplink profile&lt;/strong&gt;&lt;/u&gt;&lt;br /&gt;
Used with Transport Node (Edge and Host)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Teaming policy&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;Named policy can be selected in &amp;ldquo;Uplink Teaming Policy&amp;rdquo; of segment VLAN configuration&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;The default is the one selected for the overlay uplink/VTEP and is the same for all overlay segment.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;u&gt;&lt;strong&gt;Teaming policy&lt;/strong&gt;&lt;/u&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;On the vlan segment&lt;br /&gt;
Only &lt;strong&gt;Named Teaming Policy&lt;/strong&gt; that are associated to the &lt;strong&gt;Transport Zone&lt;/strong&gt; vlan can be selected&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;On the overlay segment&lt;br /&gt;
The teaming policy of the uplink can&amp;rsquo;t be changed. It&amp;rsquo;s inherited from the one applied to the transport node via the &lt;strong&gt;uplink profile&lt;/strong&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;On the transport node&lt;br /&gt;
The &lt;strong&gt;uplink profile&lt;/strong&gt; selected define the default teaming policy that will be applied and the possible &lt;strong&gt;Named Teaming Policy&lt;/strong&gt; for the segment vlan (Edge)&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;u&gt;&lt;strong&gt;Transport Zone&lt;/strong&gt;&lt;/u&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Used with Transport Node (Edge and Host)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Allows to tie the segments to the TN.&lt;br /&gt;
The &lt;strong&gt;Named Uplink Policy&lt;/strong&gt; is the &lt;strong&gt;Named Teaming Policy&lt;/strong&gt; that can be used by a segment vlan tied to the Transport Zone. If there is nothing that mean it will pick the default policy of the &lt;strong&gt;uplink profile&lt;/strong&gt; associated with the TN&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Uplink interfaces of the Edge VM are defined in the uplink of the TN according to the &lt;strong&gt;uplink profile&lt;/strong&gt; (if in the profile you have dedicated interface for uplinks, you need to create &lt;strong&gt;Named Teaming Policy&lt;/strong&gt; for them with different uplink names).&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;u&gt;&lt;strong&gt;Edge Uplinks&lt;/strong&gt;&lt;/u&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The IP address of the uplink is assigned on the T0 within a &lt;strong&gt;logical/virtual&lt;/strong&gt; interface. You can&amp;rsquo;t select the physical interface, you select the edge node and the segment where to assign the IP. Then you can have 1 or 2 physical uplinks based on the &lt;strong&gt;default teaming policy&lt;/strong&gt; of the uplink profile of the edge node or the &lt;strong&gt;named teaming policy&lt;/strong&gt; associated on the segment vlan. This policy can have active/active teaming and those the link selected for the outgoing traffic is based on the load balance algorithm of the teaming policy. See also Q&amp;amp;A point 4.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;To have different behavior between the overlay uplinks and the exit uplinks you need to have the exit uplinks behaviors configured as &lt;strong&gt;Named Teaming Policy&lt;/strong&gt; in the &lt;strong&gt;uplink profile&lt;/strong&gt; that you will associate to the TN.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;On the physical links you can end up having policies for the Host overlay (default teaming policy of the &lt;strong&gt;host&lt;/strong&gt; uplink profile), Edge VM overlay (default teaming policy of the &lt;strong&gt;edge VM&lt;/strong&gt; uplink profile), Edge VM uplink (named teaming policy of the &lt;strong&gt;edge VM&lt;/strong&gt; uplink profile).&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;q-a&#34;&gt;Q&amp;amp;A&lt;/h1&gt;

&lt;p&gt;&lt;details&gt;
&lt;summary&gt;Click to see the Q&amp;amp;A&lt;/summary&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Does the vtep of a transport node inherit the &lt;strong&gt;uplink profile&lt;/strong&gt; associated with the transport node ?&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;Yes&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Is the port group on the vCenter VDS7 only for vlan segment (non overlay) ?&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;Yes, for Edge VM uplink&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Does the teaming and failover policy of the port group of the host conflict with the uplink profile of the Edge VM ?&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;No, there is no conflict, just different purposes. The one on the port group will define what interface you will use as uplink for the host. If you use two physical interfaces as uplinks in the Port Group while you have only one virtual interface of the Edge VM connected on it, you loose the purpose to have deterministic uplinks.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Is this possible to have 2 interfaces active/active for an uplink transport vlan ?&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;Yes, the interface selected will be based on the load balancing method.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Can we have different policies between overlay interface and uplink interfaces ?&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;Yes, you need to specify named teaming policy and associate it to the segment vlan of the uplink.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;What if no named teaming policy is selected on the segment vlan ?&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;It uses the default teaming policy of the uplink profile of the node where the segment is deployed.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Is this possible to have a named teaming policy for overlay?&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;No&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Does the &lt;strong&gt;uplink profile&lt;/strong&gt; on the transport node override the one of the &lt;strong&gt;Transport Node Profile&lt;/strong&gt; ? Which one takes precedence ?&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;If you change the &lt;strong&gt;Transport Node Profile&lt;/strong&gt; parameters it will override the node configuration as much as there is no Transport Zone already used or interface already configured, otherwise an error will be triggered. You can override the &lt;strong&gt;Transport Node Profile&lt;/strong&gt; by changing the parameters individually on a node but then you have a warning message because you have mismatches in the node cluster between transport node.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Uplink overlay of the Edge VM are defined on the same physical link as the Host transport node, can it have different policy ?&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;Yes, see the diagram. If you use named teaming policy (NVDS) or port group (vDS7) for the Edge VM interfaces.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;In the case where you have 2 active physical interfaces, how do you know the physical interface used by the vteps IP address ?&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;I don&amp;rsquo;t think you can.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;What is the behavior of a host with a single vtep if the two uplinks are active/active ?

&lt;ul&gt;
&lt;li&gt;I think it&amp;rsquo;s behaves like in the point 4.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;What if we use the same vtep subnets for Edge VM and host ?&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;This is only possible starting from &lt;a href=&#34;https://www.virten.net/2020/11/nsx-t-3-1-enhancement-shared-esxi-and-edge-transport-vlan-with-a-single-uplink/&#34;&gt;3.1&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;How many virtual switch and &lt;strong&gt;Transport Zone&lt;/strong&gt; can we have on a TN ?&lt;br /&gt;
Those numbers can change and are not official. Don&amp;rsquo;t quote me on these.&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;TN can have up to 4 N-VDS (hostswitch)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;N-VDS can only have one TZ Overlay&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Host TN can have multiple TZ Overlay, 1 per N-VDS so 4 in total&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Edge TN can have only one TZ Overlay&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;One N-VDS can have multiple TZ VLAN&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;If we want 4 TZ Overlay it&amp;rsquo;s better to have the TZ vlan on the same NVDS as the TZ Overlay.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;/details&gt;&lt;/p&gt;

&lt;h1 id=&#34;examples&#34;&gt;Examples&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;nsxt-uplink-example.png&#34;&gt; &lt;img src=&#34;nsxt-uplink-example.png&#34; alt=&#34;&#34; /&gt; &lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Terraform One Step Further</title>
      <link>https://netmemo.github.io/post/terraform-one-step-further/</link>
      <pubDate>Wed, 26 Jan 2022 22:00:26 +0100</pubDate>
      
      <guid>https://netmemo.github.io/post/terraform-one-step-further/</guid>
      <description>

&lt;p&gt;This blog is in two parts. The &lt;a href=&#34;../terraform-bootstrap/&#34;&gt;first part&lt;/a&gt; explains what is needed to start with Terraform. This second part is to go one step further but still targets beginners.&lt;/p&gt;

&lt;p&gt;You can find more in depth articles on &lt;a href=&#34;https://blog.gruntwork.io/an-introduction-to-terraform-f17df9c6d180&#34;&gt;Gruntwork&lt;/a&gt; blog and the &lt;a href=&#34;https://www.terraform.io/language&#34;&gt;Terraform documentation&lt;/a&gt; is also very good.&lt;/p&gt;

&lt;h1 id=&#34;table-of-contents&#34;&gt;Table of contents&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../terraform-bootstrap/&#34;&gt;Terraform Bare minimum&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#terraform-one-step-further&#34;&gt;Terraform one step further&lt;/a&gt;&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#what-happens-in-the-background&#34;&gt;What happens in the background ?&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#what-happens-if-we-modify-the-object-on-gui&#34;&gt;What happens if we modify the object on GUI ?&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#how-do-i-remove-configuration&#34;&gt;How do I remove configuration ?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#what-can-we-find-in-the-state-file&#34;&gt;What can we find in the state file ?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#terraform-components&#34;&gt;Terraform components&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#variables&#34;&gt;Variables&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#variables&#34;&gt;Files&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#commands&#34;&gt;Commands&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#modules&#34;&gt;Modules&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#scaling&#34;&gt;Scaling&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#workspaces&#34;&gt;Workspaces&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#dry&#34;&gt;DRY&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;terraform-one-step-further&#34;&gt;Terraform one step further&lt;/h1&gt;

&lt;h3 id=&#34;what-happens-in-the-background&#34;&gt;What happens in the background ?&lt;/h3&gt;

&lt;p&gt;When the configuration is applied for the first time, it creates a state file to keep track of what is managed by Terraform.
The Terraform state file is a json file that you can read easily.&lt;/p&gt;

&lt;p&gt;&lt;details&gt;
&lt;summary&gt;Click to display a state file&lt;/summary&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;version&amp;quot;: 4,
  &amp;quot;terraform_version&amp;quot;: &amp;quot;1.0.0&amp;quot;,
  &amp;quot;serial&amp;quot;: 5,
  &amp;quot;lineage&amp;quot;: &amp;quot;177474d1-df80-f405-45d1-c3a6b043b4b5&amp;quot;,
  &amp;quot;outputs&amp;quot;: {},
  &amp;quot;resources&amp;quot;: [
    {
      &amp;quot;mode&amp;quot;: &amp;quot;managed&amp;quot;,
      &amp;quot;type&amp;quot;: &amp;quot;aws_vpc&amp;quot;,
      &amp;quot;name&amp;quot;: &amp;quot;netmemo&amp;quot;,
      &amp;quot;provider&amp;quot;: &amp;quot;provider[\&amp;quot;registry.terraform.io/hashicorp/aws\&amp;quot;]&amp;quot;,
      &amp;quot;instances&amp;quot;: [
        {
          &amp;quot;schema_version&amp;quot;: 1,
          &amp;quot;attributes&amp;quot;: {
            &amp;quot;arn&amp;quot;: &amp;quot;arn:aws:ec2:us-east-2:919821450090:vpc/vpc-0c53f54e268772136&amp;quot;,
            &amp;quot;assign_generated_ipv6_cidr_block&amp;quot;: false,
            &amp;quot;cidr_block&amp;quot;: &amp;quot;10.0.0.0/16&amp;quot;,
            &amp;quot;default_network_acl_id&amp;quot;: &amp;quot;acl-0856dd4ead6188e7c&amp;quot;,
            &amp;quot;default_route_table_id&amp;quot;: &amp;quot;rtb-02f6f1824fca2ea83&amp;quot;,
            &amp;quot;default_security_group_id&amp;quot;: &amp;quot;sg-082ca88831aa7e0e5&amp;quot;,
            &amp;quot;dhcp_options_id&amp;quot;: &amp;quot;dopt-b98bcbd2&amp;quot;,
            &amp;quot;enable_classiclink&amp;quot;: null,
            &amp;quot;enable_classiclink_dns_support&amp;quot;: null,
            &amp;quot;enable_dns_hostnames&amp;quot;: false,
            &amp;quot;enable_dns_support&amp;quot;: true,
            &amp;quot;id&amp;quot;: &amp;quot;vpc-0c53f54e268772136&amp;quot;,
            &amp;quot;instance_tenancy&amp;quot;: &amp;quot;default&amp;quot;,
            &amp;quot;ipv6_association_id&amp;quot;: &amp;quot;&amp;quot;,
            &amp;quot;ipv6_cidr_block&amp;quot;: &amp;quot;&amp;quot;,
            &amp;quot;main_route_table_id&amp;quot;: &amp;quot;rtb-02f6f1824fca2ea83&amp;quot;,
            &amp;quot;owner_id&amp;quot;: &amp;quot;919821450090&amp;quot;,
            &amp;quot;tags&amp;quot;: null,
            &amp;quot;tags_all&amp;quot;: {}
          },
          &amp;quot;sensitive_attributes&amp;quot;: [],
          &amp;quot;private&amp;quot;: &amp;quot;eyJzY2hlbWFfdmVyc2lvbiI6IjEifQ==&amp;quot;
        }
      ]
    }
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/details&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;terraform-state.png&#34;&gt; &lt;img src=&#34;terraform-state.png&#34; alt=&#34;&#34; /&gt; &lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;what-happens-if-we-modify-the-object-on-gui&#34;&gt;What happens if we modify the object on GUI ?&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The configuration file is the intended configuration, it becomes the source of truth.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;The resource is now managed by Terraform.&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If you apply the configuration again, it will compare it to the state file we have. If the resource is managed by Terraform it will implement the delta to make the production back as it was intended in the configuration file.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;details&gt;
&lt;summary&gt;Click to see what happens if you change the name of a VPC from the GUI and try to apply the configuration through Terraform again&lt;/summary&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;aws_vpc.netmemo: Refreshing state... [id=vpc-0fdab0a3c74e847ec]

Note: Objects have changed outside of Terraform

Terraform detected the following changes made outside of Terraform since the last &amp;quot;terraform apply&amp;quot;:

  # aws_vpc.netmemo has been changed
  ~ resource &amp;quot;aws_vpc&amp;quot; &amp;quot;netmemo&amp;quot; {
        id                               = &amp;quot;vpc-0fdab0a3c74e847ec&amp;quot;
      + tags                             = {
          + &amp;quot;Name&amp;quot; = &amp;quot;netmemo-vpc&amp;quot;
        }
      ~ tags_all                         = {
          + &amp;quot;Name&amp;quot; = &amp;quot;netmemo-vpc&amp;quot;
        }
        # (12 unchanged attributes hidden)
    }

Unless you have made equivalent changes to your configuration, or ignored the relevant attributes using ignore_changes, the following plan may include actions to undo or respond to these changes.

──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────

Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the following symbols:
  ~ update in-place

Terraform will perform the following actions:

  # aws_vpc.netmemo will be updated in-place
  ~ resource &amp;quot;aws_vpc&amp;quot; &amp;quot;netmemo&amp;quot; {
        id                               = &amp;quot;vpc-0fdab0a3c74e847ec&amp;quot;
      ~ tags                             = {
          - &amp;quot;Name&amp;quot; = &amp;quot;netmemo-vpc&amp;quot; -&amp;gt; null
        }
      ~ tags_all                         = {
          - &amp;quot;Name&amp;quot; = &amp;quot;netmemo-vpc&amp;quot;
        } -&amp;gt; (known after apply)
        # (12 unchanged attributes hidden)
    }

Plan: 0 to add, 1 to change, 0 to destroy.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/details&gt;&lt;/p&gt;

&lt;h3 id=&#34;how-do-i-remove-configuration&#34;&gt;How do I remove configuration ?&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;If you want to delete a specific resource, you just need to remove it from the Terraform configuration file. Terraform will take care of all the steps to delete it. It manages all the steps for you.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;It is the difference between a declarative approach and an imperative/procedural approach where you need to specify all the steps you need to do.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;details&gt;
&lt;summary&gt;Click to see what happens when you destroy a configuration&lt;/summary&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Terraform will perform the following actions:

  # aws_vpc.netmemo will be destroyed
  - resource &amp;quot;aws_vpc&amp;quot; &amp;quot;netmemo&amp;quot; {
      - arn                              = &amp;quot;arn:aws:ec2:us-east-2:919821450090:vpc/vpc-0fdab0a3c74e847ec&amp;quot; -&amp;gt; null
      - assign_generated_ipv6_cidr_block = false -&amp;gt; null
      - cidr_block                       = &amp;quot;10.0.0.0/16&amp;quot; -&amp;gt; null
      - default_network_acl_id           = &amp;quot;acl-0e677ba2378eaf56e&amp;quot; -&amp;gt; null
      - default_route_table_id           = &amp;quot;rtb-0ecb3bbec21918662&amp;quot; -&amp;gt; null
      - default_security_group_id        = &amp;quot;sg-0c41be3848fca4e83&amp;quot; -&amp;gt; null
      - dhcp_options_id                  = &amp;quot;dopt-b98bcbd2&amp;quot; -&amp;gt; null
      - enable_dns_hostnames             = false -&amp;gt; null
      - enable_dns_support               = true -&amp;gt; null
      - id                               = &amp;quot;vpc-0fdab0a3c74e847ec&amp;quot; -&amp;gt; null
      - instance_tenancy                 = &amp;quot;default&amp;quot; -&amp;gt; null
      - main_route_table_id              = &amp;quot;rtb-0ecb3bbec21918662&amp;quot; -&amp;gt; null
      - owner_id                         = &amp;quot;919821450090&amp;quot; -&amp;gt; null
      - tags                             = {
          - &amp;quot;Name&amp;quot; = &amp;quot;netmemo-vpc&amp;quot;
        } -&amp;gt; null
      - tags_all                         = {
          - &amp;quot;Name&amp;quot; = &amp;quot;netmemo-vpc&amp;quot;
        } -&amp;gt; null
    }

Plan: 0 to add, 0 to change, 1 to destroy.

Changes to Outputs:
  - test-output = &amp;quot;iam testing&amp;quot; -&amp;gt; null

Do you really want to destroy all resources?
  Terraform will destroy all your managed infrastructure, as shown above.
  There is no undo. Only &#39;yes&#39; will be accepted to confirm.

  Enter a value: yes

aws_vpc.netmemo: Destroying... [id=vpc-0fdab0a3c74e847ec]
aws_vpc.netmemo: Destruction complete after 1s

Destroy complete! Resources: 1 destroyed.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/details&gt;&lt;/p&gt;

&lt;h3 id=&#34;what-can-we-find-in-the-state-file&#34;&gt;What can we find in the state file ?&lt;/h3&gt;

&lt;p&gt;There are 3 types of objects in the state file:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Object&lt;/th&gt;
&lt;th&gt;Mode&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Resource&lt;/td&gt;
&lt;td&gt;Managed&lt;/td&gt;
&lt;td&gt;What we create and manage through our Terraform script&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Datasource&lt;/td&gt;
&lt;td&gt;Data&lt;/td&gt;
&lt;td&gt;import production object and work with their attributes. For instance, import a VPC that is not managed by Terraform and use the vpc_id to assign a subnet&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Output&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;td&gt;Variables&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;details&gt;
&lt;summary&gt;Click to see a resource&lt;/summary&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    &amp;quot;mode&amp;quot;: &amp;quot;managed&amp;quot;,
    &amp;quot;type&amp;quot;: &amp;quot;aws_vpc&amp;quot;,
    &amp;quot;name&amp;quot;: &amp;quot;netmemo&amp;quot;,
    &amp;quot;provider&amp;quot;: &amp;quot;provider[\&amp;quot;registry.terraform.io/hashicorp/aws\&amp;quot;]&amp;quot;,
    &amp;quot;instances&amp;quot;: [
      {
        &amp;quot;schema_version&amp;quot;: 1,
        &amp;quot;attributes&amp;quot;: {
          &amp;lt;snip&amp;gt; ..... &amp;lt;snip&amp;gt;
        },
        &amp;quot;sensitive_attributes&amp;quot;: [],
        &amp;quot;private&amp;quot;: &amp;quot;*****fdmVyc2lvbiI6IjEifQ==&amp;quot;
      }
    ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/details&gt;&lt;/p&gt;

&lt;p&gt;&lt;details&gt;
&lt;summary&gt;Click to see a datasource&lt;/summary&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    {
      &amp;quot;mode&amp;quot;: &amp;quot;data&amp;quot;,
      &amp;quot;type&amp;quot;: &amp;quot;aws_iam_policy&amp;quot;,
      &amp;quot;name&amp;quot;: &amp;quot;vpcpolicy&amp;quot;,
      &amp;quot;provider&amp;quot;: &amp;quot;provider[\&amp;quot;registry.terraform.io/hashicorp/aws\&amp;quot;]&amp;quot;,
      &amp;quot;instances&amp;quot;: [
        {
          &amp;quot;schema_version&amp;quot;: 0,
          &amp;quot;attributes&amp;quot;: {
            &amp;lt;snip&amp;gt; ..... &amp;lt;snip&amp;gt;
          },
          &amp;quot;sensitive_attributes&amp;quot;: []
        }
      ]
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/details&gt;&lt;/p&gt;

&lt;p&gt;&lt;details&gt;
&lt;summary&gt;Click to see an output&lt;/summary&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;quot;outputs&amp;quot;: {
    &amp;quot;test-output&amp;quot;: {
      &amp;quot;value&amp;quot;: &amp;quot;iam testint&amp;quot;,
      &amp;quot;type&amp;quot;: &amp;quot;string&amp;quot;
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/details&gt;&lt;/p&gt;

&lt;h1 id=&#34;terraform-components&#34;&gt;Terraform components&lt;/h1&gt;

&lt;h3 id=&#34;variables&#34;&gt;Variables&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Outputs:
This will store variables in the output section of the state file. It will also be displayed at the screen terminal when the command “plan” and “apply” are executed. Only output variables can be accessed from other Terraform modules.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Locals:
Allow to define named values that you can refer to in your configuration. It helps to do variable manipulation or substitution to make the code more readable. Use local values only in moderation, in situation where a single value or result is used in many places and that value is likely to be changed in future. The ability to easily change the value in a central place is the key advantage of local values.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;locals {
# Ids for multiple sets of EC2 instances, merged together
instance_ids = concat(aws_instance.blue.*.id, aws_instance.green.*.id)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Inputs:
It serves as parameters for a Terraform module.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Comparing to traditional programming language
Output values are like function return values.
Local values are like a function’s temporary local variables.
Input variables are like function arguments&lt;/p&gt;

&lt;h3 id=&#34;files&#34;&gt;Files&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;├─ main.tf
├─ provider.tf
├─ variables.tf
├─ outputs.tf
├─ terraform.tfvars
├─ terraform.tfstate
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;.tf&lt;/strong&gt;&lt;br /&gt;
The main file can be split into different files for the readers&amp;rsquo; convenience. The name of the .tf file can be anything. Most of the time we find:&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;File&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;main.tf&lt;/td&gt;
&lt;td&gt;Resources definition&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;provider.tf&lt;/td&gt;
&lt;td&gt;Provider definition&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;variable.tf&lt;/td&gt;
&lt;td&gt;Variable &lt;strong&gt;declaration&lt;/strong&gt; (name + type)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;outputs.tf&lt;/td&gt;
&lt;td&gt;outputs variables&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;terraform.tfvars&lt;/strong&gt;&lt;br /&gt;
It contains the input variables &lt;strong&gt;definitions&lt;/strong&gt; (value). This is used with “module” where we need different variables per infrastructure. Otherwise, the variable definition can be embedded in the default section of the variable declaration in the Terraform configuration file.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;terraform.tfstate&lt;/strong&gt;&lt;br /&gt;
To store the current state of the Terraform managed infrastructure.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;variable-declaration-and-definition&#34;&gt;Variable declaration and definition&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt; #declaration + type
 variable &amp;quot;cidr&amp;quot; {
     type = string
 }
 
 #value
 cidr = &amp;quot;10.0.0.0/24&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;commands&#34;&gt;Commands&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;terraform init&lt;/code&gt; : Download the providers.&lt;br /&gt;
&lt;code&gt;terraform plan&lt;/code&gt; : Allow to dissociate the “plan” from the “apply”. It compares the previous state and the intended config and tells you what it will plan to do to make the production as intended. With this command you can save the plan to directly apply it with the apply command when you are ready.&lt;br /&gt;
&lt;code&gt;terraform show&lt;/code&gt; : Display the current state file or the plan file created with the plan command.&lt;br /&gt;
&lt;code&gt;terraform apply&lt;/code&gt; : Push the configuration to production.&lt;br /&gt;
&lt;code&gt;terraform destroy&lt;/code&gt; : Delete all the configuration. It can be useful in CI/CD environment when we want to test things and destroy afterwards.&lt;/p&gt;

&lt;h3 id=&#34;modules&#34;&gt;Modules&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;terraform-module.png&#34;&gt; &lt;img src=&#34;terraform-module.png&#34; alt=&#34;&#34; /&gt; &lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Root module.&lt;br /&gt;
This is the main program that will create the infrastructure.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Child module.&lt;br /&gt;
This is the module called from the root module. It allows to externalize repeatable code. By centralizing the code, it becomes more manageable.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;scaling&#34;&gt;Scaling&lt;/h1&gt;

&lt;h3 id=&#34;workspaces&#34;&gt;Workspaces&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Workspaces&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;Shared storage for state files : Access to all members of the team&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Locking state files : Prevent concurrent modification&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Isolating state files : Several environments and variables&lt;br /&gt;
&lt;BR&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Terraform Cloud/Enterprise&lt;br /&gt;
This is an infrastructure component SaaS for Terraform Cloud and on-premises server for Terraform Enterprise.
This software allows to manage workspaces, variables, state file locking, password and provide API to interface Terraform with other software like Github.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;terraform-tfe.png&#34;&gt; &lt;img src=&#34;terraform-tfe.png&#34; alt=&#34;&#34; /&gt; &lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;dry&#34;&gt;DRY&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Keep your code DRY (Don’t Repeat Yourself)&lt;br /&gt;
&lt;a href=&#34;https://www.terraform.io/language/meta-arguments/for_each&#34;&gt;for_each&lt;/a&gt; : Allow to loop over a resource to create it several times according to variables that you define in your variable.tf file.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Without for_each&lt;/strong&gt;&lt;br /&gt;
Every time you add a subnet you need to create an entire block of resources.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;resource “aws_subnet” “subnet1” {
   cidr_block	= “10.0.1.0/24”
   vpc_id	= “myvpcid”
}

resource “aws_subnet” “subnet2” {
   cidr_block	= “10.0.2.0/24”
   vpc_id	= “myvpcid”
}

resource “aws_subnet” “subnet13” {
   cidr_block	= “10.0.3.0/24”
   vpc_id	= “myvpcid”
}

resource “aws_subnet” “subnet4” {
   cidr_block	= “10.0.4.0/24”
   vpc_id	= “myvpcid”
}

resource “aws_subnet” “subnet5” {
   cidr_block	= “10.0.5.0/24”
   vpc_id	= “myvpcid”
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;With for_each&lt;/strong&gt;&lt;br /&gt;
Every time you add a subnet you need add a line in the variable.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#variable declaration
variable “setofsubnet” {
    type = set(string)
}

#variable definition
setofsubnet = [
   “10.0.1.0/24”,
   “10.0.2.0/24”,
   “10.0.3.0/24”,
   “10.0.4.0/24”,
   “10.0.5.0/24”
]

#resource creation
resource “aws_subnet” “main-subnet” {
   for_each = var.listofsubnet
   cidr_block = each.key
   vpc_id = “myvpcid”
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can find very good &lt;a href=&#34;https://blog.gruntwork.io/terraform-tips-tricks-loops-if-statements-and-gotchas-f739bbae55f9&#34;&gt;tips&lt;/a&gt; around loops on the Gruntwork blog.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Terraform Bootstrap</title>
      <link>https://netmemo.github.io/post/terraform-bootstrap/</link>
      <pubDate>Wed, 19 Jan 2022 18:40:34 +0100</pubDate>
      
      <guid>https://netmemo.github.io/post/terraform-bootstrap/</guid>
      <description>

&lt;p&gt;This blog is in two parts. This first part explains what is needed to start with Terraform, the &lt;a href=&#34;../terraform-one-step-further/&#34;&gt;second part&lt;/a&gt; is to go one step further but still targets beginners.&lt;/p&gt;

&lt;h1 id=&#34;table-of-content&#34;&gt;Table of content&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#terraform-bare-minimum&#34;&gt;Terraform bare minimum&lt;/a&gt;&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#terraform-what-is-it&#34;&gt;Terraform, what is it ?&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#what-do-you-need-to-provision-something-with-terraform&#34;&gt;What do I need to provision something with Terraform ?&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#how-do-i-know-what-to-create&#34;&gt;How do I know what to create ?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#the-configuration-is-made-of-3-blocks&#34;&gt;The configuration is made of 3 blocks&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#you-need-2-commands-to-push-your-first-configuration&#34;&gt;You need 2 commands to push your first configuration&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#demo-time&#34;&gt;Demo time&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../terraform-one-step-further/&#34;&gt;One step further&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;terraform-bare-minimum&#34;&gt;Terraform bare minimum&lt;/h1&gt;

&lt;h3 id=&#34;terraform-what-is-it&#34;&gt;Terraform, what is it ?&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.terraform.io/&#34;&gt;Terraform&lt;/a&gt; allows to manage infrastructure thanks to the configuration file known as infrastructure as Code (IaC). It allows to create reproducible infrastructure.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.terraform.io/&#34;&gt;Terraform&lt;/a&gt; determines what has changed and creates incremental execution plans that respect dependencies. It is &lt;a href=&#34;https://en.wikipedia.org/wiki/Idempotence&#34;&gt;idempotent&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;what-do-i-need-to-provision-something-with-terraform&#34;&gt;What do I need to provision something with Terraform ?&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.terraform.io/downloads&#34;&gt;terraform.exe&lt;/a&gt; file&lt;/li&gt;
&lt;li&gt;One configuration file&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;terraform-simple.png&#34;&gt; &lt;img src=&#34;terraform-simple.png&#34; alt=&#34;&#34; /&gt; &lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;how-do-i-know-what-to-create&#34;&gt;How do I know what to create ?&lt;/h3&gt;

&lt;p&gt;Most of the time you need the &lt;a href=&#34;https://registry.terraform.io/namespaces/hashicorp&#34;&gt;documentation&lt;/a&gt; of the provider you want to use. The &lt;a href=&#34;https://registry.terraform.io/namespaces/hashicorp&#34;&gt;documentation&lt;/a&gt; often respect the same structure and it&amp;rsquo;s easy to browse.
These are the main providers that I use &lt;a href=&#34;https://registry.terraform.io/providers/vmware/nsxt/latest/docs&#34;&gt;NSX-T&lt;/a&gt;/&lt;a href=&#34;https://registry.terraform.io/providers/CiscoDevNet/aci/latest/docs&#34;&gt;ACI&lt;/a&gt;/&lt;a href=&#34;https://registry.terraform.io/providers/hashicorp/aws/latest/docs&#34;&gt;AWS&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;the-configuration-is-made-of-3-blocks&#34;&gt;The configuration is made of 3 blocks&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Block&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Terraform&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;What&lt;/strong&gt; provider to use&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Provider&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Where&lt;/strong&gt; to push the configuration&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Resources&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;What&lt;/strong&gt; to create&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;pre&gt;&lt;code&gt;terraform provider{
    required_provider{
        aws = {
            source  = &amp;quot;hashicorp/aws&amp;quot;
            version = &amp;quot;3.55.0&amp;quot;
        }
    }
}

provider &amp;quot;aws&amp;quot; {
    region = &amp;quot;us-east-2&amp;quot;
    access_-_key = &amp;quot;**********&amp;quot;
    secret_key = &amp;quot;**********&amp;quot;
}

resource &amp;quot;aws_s3_bucket&amp;quot; &amp;quot;netmemo_bucket&amp;quot; {
    bucket = &amp;quot;netmemo_bucket&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;you-need-2-commands-to-push-your-first-configuration&#34;&gt;You need 2 commands to push your first configuration&lt;/h3&gt;

&lt;p&gt;When the first initialization has been done, you will only need the apply command for the next infrastructure modifications.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;terraform init&lt;/code&gt;      =&amp;gt; Download and configure the provider&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;terraform apply&lt;/code&gt;     =&amp;gt; It tells you what it will do then push the configuration&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;proxy-white-listing&#34;&gt;Proxy white listing&lt;/h3&gt;

&lt;p&gt;In enterprise, don’t forget to whitelist URLs. Below is an example for AWS.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;To download the providers / backend init&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://registry.terraform.io&#34;&gt;https://registry.terraform.io&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://releases.hashicorp.com&#34;&gt;https://releases.hashicorp.com&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;To authenticate to the providers

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://iam.amazonaws.com/&#34;&gt;https://iam.amazonaws.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://sts.amazonaws.com/&#34;&gt;https://sts.amazonaws.com/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;To push the configuration

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://us-east-2.amazonaws.com/&#34;&gt;https://us-east-2.amazonaws.com/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;demo-time&#34;&gt;DEMO TIME&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;terraform-demo.gif&#34;&gt; &lt;img src=&#34;terraform-demo.gif&#34; alt=&#34;&#34; /&gt; &lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Cisco ACI Terraform Policy Model</title>
      <link>https://netmemo.github.io/post/aci-terraform-policy-model/</link>
      <pubDate>Wed, 15 Dec 2021 18:40:34 +0100</pubDate>
      
      <guid>https://netmemo.github.io/post/aci-terraform-policy-model/</guid>
      <description>

&lt;h1 id=&#34;the-big-picture&#34;&gt;The big picture&lt;/h1&gt;

&lt;p&gt;This blog post is a memo for the ACI Terraform policy model. I have struggled to find equivalences between ACI REST API Call / Classes and Terraform resources. Below you can find the full diagram. The diagram is not exhaustive but I think I have reached a point where I can published something. I will probably modify or add things if I use more resources or if people correct me but I think it is a good start. L3 out is very complex that&amp;rsquo;s why the diagram ends up being complex. I don&amp;rsquo;t cover all cases for L3 out, only the one I have been using so far.&lt;/p&gt;

&lt;p&gt;You will be able to find the source of this diagram &lt;a href=&#34;https://github.com/netmemo/netmemo.github.io/tree/master/post/aci-terraform-policy-model/aci-l3out-blog.drawio&#34;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;ACI-L3out-3-full.drawio.png&#34;&gt; &lt;img src=&#34;ACI-L3out-3-full.drawio.png&#34; alt=&#34;&#34; /&gt; &lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;the-small-picture&#34;&gt;The small picture&lt;/h1&gt;

&lt;p&gt;This second diagram is lighter. This is when you are not using L3out or static path bing and contracts. It looks more like the &amp;ldquo;Figure 1.&amp;rdquo; in Fabric Connectivity chapter of &lt;a href=&#34;https://www.cisco.com/c/en/us/td/docs/switches/datacenter/aci/apic/sw/1-x/Operating_ACI/guide/b_Cisco_Operating_ACI/b_Cisco_Operating_ACI_chapter_0110.html&#34;&gt;Operating Cisco Application Centric Infrastructure&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;ACI-L3out-3-light.drawio.png&#34;&gt; &lt;img src=&#34;ACI-L3out-3-light.drawio.png&#34; alt=&#34;&#34; /&gt; &lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Can we ping an AWS Lambda function ?</title>
      <link>https://netmemo.github.io/post/lambdaping/</link>
      <pubDate>Tue, 16 Nov 2021 18:00:45 +0200</pubDate>
      
      <guid>https://netmemo.github.io/post/lambdaping/</guid>
      <description>

&lt;h1 id=&#34;context&#34;&gt;Context&lt;/h1&gt;

&lt;p&gt;Can we ping the ENI of an AWS Lambda function within the VPC ? While the answer can be &lt;a href=&#34;#obvious&#34;&gt;obvious&lt;/a&gt; the path to get it was insightful for me and has helped me to be more comfortable with :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;AWS IAM.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;AWS Lambdas function.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;AWS Static IP addresses and AWS default subnets.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This test can be performed with the AWS free tier. You will find the Terraform scripts here : &lt;a href=&#34;https://github.com/netmemo/lambdaping&#34;&gt;Lambda Ping&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I am a network engineer, I like diagram. Below you can find the diagram of the test.
&lt;a href=&#34;lambdaping.png&#34;&gt; &lt;img src=&#34;lambdaping.png&#34; alt=&#34;&#34; /&gt; &lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What needs to be created&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Infrastrusture:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;aws_key_pair&lt;/li&gt;
&lt;li&gt;aws_default_subnet&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;aws_security_group&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;aws_instance&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Script:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A python script executed with the AWS lambda function&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;IAM:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;aws_iam_role&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;aws_iam_role_policy_attachment&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;aws_iam_policy&lt;/li&gt;
&lt;li&gt;aws_iam_policy_document&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Lambda:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;aws_lambda_function&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This test is a good demonstration of one of the terraform benefits. Terraform is taking care of the dependencies and the order of creation between all resources.
In the case of an imperative model for &lt;strong&gt;aws_key_pair&lt;/strong&gt; and &lt;strong&gt;aws_instance&lt;/strong&gt; you will need to explicitly state that &lt;strong&gt;aws_key_pair&lt;/strong&gt; needs to be created before &lt;strong&gt;aws_instance&lt;/strong&gt; is created. With the declarative approach of Terraform, you just declare the resources you want and Terraform is taking care of the execution order.&lt;/p&gt;

&lt;h1 id=&#34;resources-creation&#34;&gt;Resources creation&lt;/h1&gt;

&lt;h2 id=&#34;infrastructure&#34;&gt;Infrastructure&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;aws_key&lt;/strong&gt;&lt;br /&gt;
This is to push the public key of the computer that will be allowed to connect to the EC2 VM Instance.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;resource &amp;quot;aws_key_pair&amp;quot; &amp;quot;deployer&amp;quot; {
	key_name   = &amp;quot;deployer-key&amp;quot;
	public_key = file(&amp;quot;~/.ssh/id_rsa.pub&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;aws_default_subnet&lt;/strong&gt;&lt;br /&gt;
This resource &lt;strong&gt;can&amp;rsquo;t&lt;/strong&gt; modify the default subnet address but it allows you to retrieve it from your default VPC.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;resource &amp;quot;aws_default_subnet&amp;quot; &amp;quot;default_az1&amp;quot; {
  availability_zone = &amp;quot;us-east-2a&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;aws_security_group&lt;/strong&gt;&lt;br /&gt;
This will be the security group for the test. This security group will be assigned to the VM and the AWS lambda function to allow SSH to the VM, HTTP, ICMP between each other and outgoing traffic.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;resource &amp;quot;aws_security_group&amp;quot; &amp;quot;sglambdaping&amp;quot; {
  name        = &amp;quot;sglambdaping&amp;quot;
  description = &amp;quot;Allow HTTP, ICMP and SSH traffic&amp;quot;

  ingress {
    description = &amp;quot;SSH&amp;quot;
    from_port   = 22
    to_port     = 22
    protocol    = &amp;quot;tcp&amp;quot;
    cidr_blocks = [&amp;quot;0.0.0.0/0&amp;quot;]
  }

  ingress {
    description = &amp;quot;HTTP&amp;quot;
    from_port   = 80
    to_port     = 80
    protocol    = &amp;quot;tcp&amp;quot;
    cidr_blocks = [&amp;quot;0.0.0.0/0&amp;quot;]
  }

  ingress {
    description = &amp;quot;ALL_ICMP&amp;quot;
    from_port = -1
    to_port = -1
    protocol = &amp;quot;icmp&amp;quot;
    cidr_blocks = [&amp;quot;0.0.0.0/0&amp;quot;]
  }

  egress {
    from_port   = 0
    to_port     = 0
    protocol    = &amp;quot;-1&amp;quot;
    cidr_blocks = [&amp;quot;0.0.0.0/0&amp;quot;]
  }

  tags = {
    Name = &amp;quot;terraform&amp;quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;aws_instance&lt;/strong&gt;&lt;br /&gt;
The t2.micro VM instance. It will host one webserver to test that the &lt;a href=&#34;https://aws.amazon.com/blogs/compute/announcing-improved-vpc-networking-for-aws-lambda-functions/&#34;&gt;ENI&lt;/a&gt; of the Lambda function works in our VPC by accessing it. This is also from this VM that we will try to ping the Lambda function&amp;rsquo;s ENI. I assign the VM to the default subnet of AZ1 which is normally 172.31.0.0/24. In the Terraform script I&amp;rsquo;m installing the webserver. I also assign a static IP address to be able to access the web server from the lambda function.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;resource &amp;quot;aws_instance&amp;quot; &amp;quot;foo&amp;quot; {
  ami           = &amp;quot;ami-0443305dabd4be2bc&amp;quot;
  instance_type = &amp;quot;t2.micro&amp;quot;
  key_name      = aws_key_pair.deployer.key_name

  user_data     = &amp;lt;&amp;lt;-EOF
                  #!/bin/bash
                  sudo su
                  yum -y install httpd
                  echo &amp;quot;&amp;lt;p&amp;gt; My Instance! &amp;lt;/p&amp;gt;&amp;quot; &amp;gt;&amp;gt; /var/www/html/index.html
                  sudo systemctl enable httpd
                  sudo systemctl start httpd
                  EOF

  vpc_security_group_ids = [
    aws_security_group.ubuntu.id
  ]

  private_ip = &amp;quot;172.31.0.8&amp;quot;
  subnet_id  = aws_default_subnet.default_az1.id
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;python-script&#34;&gt;Python script&lt;/h2&gt;

&lt;p&gt;For the lambda part we first need a code that the function will execute. In this example it will be a HTTP request to our EC2 VM done with python urllib3 library.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#import json
import urllib3

print(&#39;Loading function&#39;)
def lambda_handler(event, context):
    http = urllib3.PoolManager()
    resp = http.request(&amp;quot;GET&amp;quot;, &amp;quot;http://172.31.0.8&amp;quot;)
    print(resp.data)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once the script is ready, you need to zip it then place the zip in the same directory as your Terraform script that will create the function.
We then need to create the lambda resources.&lt;/p&gt;

&lt;h2 id=&#34;iam&#34;&gt;IAM&lt;/h2&gt;

&lt;p&gt;In this &lt;a href=&#34;https://netmemo.github.io/post/tf-iam-roles/&#34;&gt;post&lt;/a&gt; I explain in detail what the role, the assume_role_policy and the policy are used for.&lt;/p&gt;

&lt;p&gt;First we load a default AWS Managed Policy that will allow the lambda function to create the ENI in the VPC.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;aws_iam_policy&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;data &amp;quot;aws_iam_policy&amp;quot; &amp;quot;vpcpolicy&amp;quot; {
 name = &amp;quot;AWSLambdaVPCAccessExecutionRole&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We then create the role that will use this policy.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;aws_iam_role&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;resource &amp;quot;aws_iam_role&amp;quot; &amp;quot;role-lambda&amp;quot; {
  name               = &amp;quot;nbolambdarole&amp;quot;
  assume_role_policy = data.aws_iam_policy_document.lambda_role.json
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this role we need to mention who will use it. In our case this is the lambda function. This action is done by defining a policy document where the principal is a lambda function.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;aws_iam_policy_document&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;data &amp;quot;aws_iam_policy_document&amp;quot; &amp;quot;lambda_role&amp;quot; {
  statement {
    effect  = &amp;quot;Allow&amp;quot;
    actions = [&amp;quot;sts:AssumeRole&amp;quot;]

    principals {
      type        = &amp;quot;Service&amp;quot;
      identifiers = [&amp;quot;lambda.amazonaws.com&amp;quot;]
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we assign this policy to the assume_role_policy of the role&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  assume_role_policy = data.aws_iam_policy_document.lambda_role.json
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The last step of the IAM configuration is to attach the role and the policy together.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;aws_iam_role_policy_attachment&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;resource &amp;quot;aws_iam_role_policy_attachment&amp;quot; &amp;quot;role-policy-attach&amp;quot; {
  role       = aws_iam_role.role-lambda.name
  policy_arn = data.aws_iam_policy.vpcpolicy.arn
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;lambda&#34;&gt;Lambda&lt;/h2&gt;

&lt;p&gt;Once the IAM part is done, we can create the lambda function. In our case we assign the previously created role to the function and the python script zip file.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;aws_lambda_function&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;resource &amp;quot;aws_lambda_function&amp;quot; &amp;quot;lambda-get&amp;quot; {
  function_name = &amp;quot;nbo-tf-helloword-3&amp;quot;
  role          = aws_iam_role.role-lambda.arn
  filename         = &amp;quot;lambda_function.zip&amp;quot;
  source_code_hash = filebase64sha256(&amp;quot;lambda_function.zip&amp;quot;)
  runtime = &amp;quot;python3.9&amp;quot;
  handler = &amp;quot;lambda_function.lambda_handler&amp;quot;

  vpc_config {
      subnet_ids = [aws_default_subnet.default_az1.id]
      security_group_ids = [aws_security_group.sglambda.id]
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;The &lt;strong&gt;source_code_hash&lt;/strong&gt; is used to see if the lambda function has changed and then need to be updated.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;The &lt;a href=&#34;https://docs.aws.amazon.com/lambda/latest/dg/python-handler.html&#34;&gt;handler&lt;/a&gt; is normally the name of the python script dot the name of the python method you want to execute.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;vpc_config&lt;/strong&gt; is the VPC part of the lambda configuration to specify the security group associated to the lambda ENI and the subnet where the ENI will be.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;the-tests&#34;&gt;The tests&lt;/h2&gt;

&lt;p&gt;Lambda will access the web server to validate the communication. To launch the test, we need to create an empty event that will be selected when we will click on the orange test button.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;test-event.png&#34;&gt; &lt;img src=&#34;test-event.png&#34; alt=&#34;&#34; /&gt; &lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Click on the orange test button :) It should reply &amp;ldquo;My Instance&amp;rdquo;
&lt;a href=&#34;lambda-request.png&#34;&gt; &lt;img src=&#34;lambda-request.png&#34; alt=&#34;&#34; /&gt; &lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;obvious&#34;&gt;&lt;/a&gt;&lt;br /&gt;
After the communication is validated, we can connect to the EC2 VM instance to launch the ping command. It will fail to ping the Lambda function.&lt;br /&gt;
&lt;a href=&#34;ping-fail.png&#34;&gt; &lt;img src=&#34;ping-fail.png&#34; alt=&#34;&#34; /&gt; &lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;challenges-of-this-test&#34;&gt;Challenges of this test&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Understand the AWS IAM concept for the lambda function. The lambda function needs VPC rights to create the ENI in the VPC.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Find what default python library was available with AWS python to execute the HTTP request.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Understand how the lambda tests are done and what is a &lt;a href=&#34;https://docs.aws.amazon.com/lambda/latest/dg/python-handler.html&#34;&gt;handler&lt;/a&gt;.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>AWS IAM Roles with Terraform</title>
      <link>https://netmemo.github.io/post/tf-iam-roles/</link>
      <pubDate>Mon, 27 Sep 2021 18:04:31 +0200</pubDate>
      
      <guid>https://netmemo.github.io/post/tf-iam-roles/</guid>
      <description>

&lt;p&gt;An IAM role is an AWS identity with permission policies that determine what the identity can and cannot do in AWS.&lt;/p&gt;

&lt;h1 id=&#34;tl-dr&#34;&gt;TL;DR&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;The &lt;strong&gt;&lt;a href=&#34;https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements_principal.html&#34;&gt;principal&lt;/a&gt;&lt;/strong&gt; is &lt;strong&gt;WHO&lt;/strong&gt; will be able to access a resource.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;The &lt;strong&gt;policy&lt;/strong&gt; is &lt;strong&gt;WHAT&lt;/strong&gt; the principals associated with the role will be able to do.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;The &lt;strong&gt;role&lt;/strong&gt; links the principals thanks to the &lt;em&gt;assume_role_policy&lt;/em&gt; with the &lt;em&gt;inline policy&lt;/em&gt; argument.&lt;/li&gt;
&lt;li&gt;The &lt;strong&gt;attachement&lt;/strong&gt; links the role to a &lt;em&gt;managed policies&lt;/em&gt; instead of the &lt;em&gt;inline policy&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;aws-iam-simple.png&#34;&gt; &lt;img src=&#34;aws-iam-simple.png&#34; alt=&#34;&#34; /&gt; &lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;terraform-resources-and-aws-api&#34;&gt;Terraform resources and AWS API&lt;/h1&gt;

&lt;h3 id=&#34;policy&#34;&gt;Policy&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/iam_policy&#34;&gt;aws_iam_policy&lt;/a&gt; | &lt;a href=&#34;https://docs.aws.amazon.com/IAM/latest/APIReference/API_CreatePolicy.html&#34;&gt;aws create policy API&lt;/a&gt;&lt;br /&gt;
There are 3 types of policies.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Inline :  The policy is defined directly in the object that needs it.&lt;/li&gt;
&lt;li&gt;Managed : More flexible, can be reused with several roles. Need to be attached with an object.&lt;/li&gt;
&lt;li&gt;AWS Managed : Same advantages as the managed ones but can&amp;rsquo;t be modified.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Here is a link that helps to &lt;a href=&#34;https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_managed-vs-inline.html#choosing-managed-or-inline&#34;&gt;choose&lt;/a&gt; between them.&lt;/p&gt;

&lt;h3 id=&#34;role&#34;&gt;Role&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/iam_role&#34;&gt;aws_iam_role&lt;/a&gt; | &lt;a href=&#34;https://docs.aws.amazon.com/IAM/latest/APIReference/API_CreateRole.html&#34;&gt;aws create role API&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This is to define the IAM role resource that will link the principals and the policy.&lt;br /&gt;
If we are using &lt;em&gt;managed policy&lt;/em&gt; we will need to link this role to the &lt;em&gt;managed policy&lt;/em&gt; with an attachment resource. In case of using &lt;em&gt;inline policy&lt;/em&gt;, the &lt;em&gt;inline policy&lt;/em&gt; is declared in the Terraform resource role. With AWS API, it needs &lt;a href=&#34;https://docs.aws.amazon.com/IAM/latest/APIReference/API_PutRolePolicy.html&#34;&gt;another API call&lt;/a&gt; to set the &lt;em&gt;inline policy&lt;/em&gt; in the &lt;em&gt;role&lt;/em&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;assume_role_policy&lt;/strong&gt;&lt;br /&gt;
This is a mandatory argument used in aws_iam_role and aws_iam_role_policy to indicate &lt;strong&gt;WHO&lt;/strong&gt; can temporarily assume the role that we are defining. It&amp;rsquo;s also referred as trust policy.&lt;br /&gt;
&lt;a href=&#34;https://stackoverflow.com/questions/44628380/terraform-assume-role-policy-similar-but-slightly-different-than-standard-ia&#34;&gt;explanation 1&lt;/a&gt;, &lt;a href=&#34;https://aws.amazon.com/blogs/security/how-to-use-trust-policies-with-iam-roles/&#34;&gt;explanation 2&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;attachments&#34;&gt;Attachments&lt;/h3&gt;

&lt;p&gt;Attach a &lt;em&gt;managed policy&lt;/em&gt; to a group, user or role&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/iam_group_policy_attachment&#34;&gt;aws_iam_group_policy_attachment&lt;/a&gt; | &lt;a href=&#34;https://docs.aws.amazon.com/IAM/latest/APIReference/API_AttachGroupPolicy.html&#34;&gt;aws attach group policy API&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/iam_user_policy_attachment&#34;&gt;aws_iam_user_policy_attachment&lt;/a&gt; | &lt;a href=&#34;https://docs.aws.amazon.com/IAM/latest/APIReference/API_AttachUserPolicy.html&#34;&gt;aws attach user policy API&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/iam_role_policy_attachment&#34;&gt;aws_iam_role_policy_attachment&lt;/a&gt; | &lt;a href=&#34;https://docs.aws.amazon.com/IAM/latest/APIReference/API_AttachRolePolicy.html&#34;&gt;aws attach role policy API&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;possibilities-of-policy-attachment&#34;&gt;Possibilities of policy attachment&lt;/h1&gt;

&lt;p&gt;From the less flexible to the most flexible:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;1 resource: aws_iam_role with &lt;em&gt;inline_policy&lt;/em&gt; argument&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;2 resources: aws_iam_role + aws_iam_role_policy (conflict with aws_iam_role / inline_policy)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;3 resources: aws_iam_role + aws_iam_policy + aws_iam_role_policy_attachment&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;terraform-specific-resources&#34;&gt;Terraform specific resources&lt;/h1&gt;

&lt;h3 id=&#34;datasource&#34;&gt;Datasource&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://registry.terraform.io/providers/hashicorp/aws/latest/docs/data-sources/iam_policy_document&#34;&gt;aws_iam_policy_document&lt;/a&gt;.
This is an optional datasource which is Terraform specific. The policy defined in HCL format is translated to JSON when associated with the inline policy attribute of the role.
The advantages of using this &lt;a href=&#34;https://learn.hashicorp.com/tutorials/terraform/aws-iam-policy?_ga=2.99142555.466421101.1630266824-70591653.1623679226&#34;&gt;Policy in HCL format&lt;/a&gt; are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Being able to overwrite, append, or update policies with this resource by using the source_json and override_json arguments.&lt;/li&gt;
&lt;li&gt;Terraform error checking automatically formats your policy document into correct JSON when you run your apply.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Data sources make it easier to reuse policies throughout your environment.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;It can be used in the below resources.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;aws_iam_policy / &lt;em&gt;policy&lt;/em&gt; argument&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;aws_iam_role_policy / &lt;em&gt;policy&lt;/em&gt; argument&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;aws_iam_role_policy / &lt;em&gt;assume_role_policy&lt;/em&gt; argument&lt;/li&gt;
&lt;li&gt;aws_iam_role / &lt;em&gt;assume_role_policy&lt;/em&gt; argument&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;inline-policy-resources&#34;&gt;Inline policy resources&lt;/h3&gt;

&lt;p&gt;Provide an IAM user/role/group with an inline policy.
The aim is to reduce the number of Terraform resources to give access to a role/user/group. You can directly use them instead of creating a role/user/group, the policy and the attachement to link both (2 vs 3 resources).
There is an &lt;strong&gt;overlap&lt;/strong&gt; between the &lt;em&gt;aws_iam_role_policy&lt;/em&gt; and the &lt;em&gt;aws_iam_role&lt;/em&gt; / &lt;em&gt;inline_policy&lt;/em&gt; argument. There are incompatible.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/iam_user_policy&#34;&gt;aws_iam_user_policy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/iam_role_policy&#34;&gt;aws_iam_role_policy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/iam_group_policy&#34;&gt;aws_iam_group_policy&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;attachment&#34;&gt;Attachment&lt;/h3&gt;

&lt;p&gt;There are lots of &lt;strong&gt;overlap&lt;/strong&gt;, &lt;strong&gt;incompatibility&lt;/strong&gt; and &lt;strong&gt;conflict&lt;/strong&gt; with this resource.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/iam_policy_attachment&#34;&gt;aws_iam_policy_attachment&lt;/a&gt; EXCLUSIVE with other attachements.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;conflict with aws_iam_user_policy_attachment, aws_iam_group_policy_attachment, aws_iam_role_policy_attachment&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;bonus&#34;&gt;Bonus :)&lt;/h3&gt;

&lt;p&gt;As a bonus here are the &lt;a href=&#34;https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_iam-quotas.html&#34;&gt;quotas&lt;/a&gt; for IAM and STS&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Github Actions with Terraform Cloud for CI/CD of NSX-T</title>
      <link>https://netmemo.github.io/post/tf-gha-nsxt-cicd/</link>
      <pubDate>Sun, 15 Aug 2021 14:02:39 +0200</pubDate>
      
      <guid>https://netmemo.github.io/post/tf-gha-nsxt-cicd/</guid>
      <description>

&lt;p&gt;This post is to show an example of using CI/CD with Terraform Cloud and &lt;a href=&#34;https://learn.hashicorp.com/tutorials/terraform/github-actions&#34;&gt;Github Actions&lt;/a&gt; in order to have a better NetDevOps approach by doing NSX-T Network Infrastructure as code (IaC).
It&amp;rsquo;s almost a bingo, I think I have most of the buzz words of these last years :)&lt;/p&gt;

&lt;p&gt;I will describe the structure of the project, the project components, the project workflow and finish with how to test this project.&lt;/p&gt;

&lt;h1 id=&#34;structure-of-the-project&#34;&gt;Structure of the project&lt;/h1&gt;

&lt;p&gt;The diagram below shows a high level view of the &lt;a href=&#34;https://github.com/netmemo/tf-gha-nsxt-cicd&#34;&gt;project&lt;/a&gt;.
&lt;a href=&#34;tf-gha-cicd-nsx.png&#34;&gt; &lt;img src=&#34;tf-gha-cicd-nsx.png&#34; alt=&#34;&#34; /&gt; &lt;/a&gt;&lt;/p&gt;

&lt;p&gt;You can find the file structure of the project below&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.
├─ main.tf
├─ .github
   └── workflows
       ├── dev-to-pr.yml
       ├── plan-prod.yml
       └── apply-prod.yml
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;project-components&#34;&gt;Project components&lt;/h1&gt;

&lt;h2 id=&#34;nsx-t&#34;&gt;NSX-T&lt;/h2&gt;

&lt;p&gt;For this project we need two NSXT environments, one for production and one for development. You can either have 2 full blown NSX-T or use different variables for prod and dev or different VRFs.
In this blog post we will use two different deployments.&lt;/p&gt;

&lt;h2 id=&#34;terraform-cloud&#34;&gt;Terraform Cloud&lt;/h2&gt;

&lt;p&gt;Terraform Cloud will be used to store the state of the prod and dev environment. It will also allow to manage Terraform through APIs.
For the project we need to create 2 differents workspaces, one for production and one for developments.
The name of the workspaces should be prefix-suffix where the prefix will be what is configured in your terraform configuration file and the sufix will be what is used to select the workspace. We will cover how to select the workspace later in that post.
For this blog post, the prefix will be netmemo- and the suffix will be either prod or dev.
&lt;a href=&#34;workspaces.png&#34;&gt; &lt;img src=&#34;workspaces.png&#34; alt=&#34;&#34; /&gt; &lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Once the workspaces are created, we need to add 3 variables for the NSX-T provider:
&lt;a href=&#34;tf-variables.png&#34;&gt; &lt;img src=&#34;tf-variables.png&#34; alt=&#34;&#34; /&gt; &lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Finally we need to add the API key that Github Actions will use to connect to Terraform Cloud
&lt;a href=&#34;tf-token.png&#34;&gt; &lt;img src=&#34;tf-token.png&#34; alt=&#34;&#34; /&gt; &lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;github&#34;&gt;Github&lt;/h2&gt;

&lt;p&gt;Github is where we will store the configuration and execute our CI/CD pipelines.
Once the project is forked, to make it works, we need to enable Github Actions.
&lt;a href=&#34;enable-gha.png&#34;&gt; &lt;img src=&#34;enable-gha.png&#34; alt=&#34;&#34; /&gt; &lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Create a github &lt;a href=&#34;https://github.com/settings/tokens&#34;&gt;personal access token&lt;/a&gt; &lt;em&gt;REPO_TOKEN&lt;/em&gt;. This token will be used by Github Actions to automatically create the pull request.&lt;br /&gt;
&lt;a href=&#34;gh-perso-token.png&#34;&gt; &lt;img src=&#34;gh-perso-token.png&#34; alt=&#34;&#34; /&gt; &lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Add the previously created token (TF_API_TOKEN and REPO_TOKEN_SECRET) to your github &lt;a href=&#34;https://github.com/netmemo/nsxt-tfc-rm/settings/secrets/actions&#34;&gt;repository secrets&lt;/a&gt;.&lt;br /&gt;
&lt;a href=&#34;repo-secret.png&#34;&gt; &lt;img src=&#34;repo-secret.png&#34; alt=&#34;&#34; /&gt; &lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;github-actions&#34;&gt;Github Actions&lt;/h2&gt;

&lt;p&gt;This project is made from 3 scripts that form 3 pipelines. The first script will handle the dev environment. The second will handle the &lt;em&gt;terraform plan&lt;/em&gt; for the prod environments. The third will handle the &lt;em&gt;terraform apply&lt;/em&gt; for the prod environment.&lt;/p&gt;

&lt;p&gt;You can find an explanation of the main steps on the below site &lt;a href=&#34;https://learn.hashicorp.com/tutorials/terraform/github-actions&#34;&gt;Github Actions&lt;/a&gt;.&lt;/p&gt;

&lt;h4 id=&#34;dev-to-pr-yml&#34;&gt;dev-to-pr.yml&lt;/h4&gt;

&lt;p&gt;The dev-to-pr.yml Github Actions YAML file will be executed only after a &lt;em&gt;push&lt;/em&gt; on the &lt;em&gt;dev&lt;/em&gt; branch.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;on:
  push:
    branches:
      - dev
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first step is to checkout the current configuration.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      - name: Checkout
        uses: actions/checkout@v2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then the &lt;em&gt;Setup Terraform&lt;/em&gt; steps retrieves the Terraform CLI used in the GitHub action workflow.
This is in this step that we will use the TF_API_TOKEN that we have created previously to access Terraform Cloud from Github Actions.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v1
        with:
          # terraform_version: 0.13.0:
          cli_config_credentials_token: ${{ secrets.TF_API_TOKEN }}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These following steps initialize Terraform and set the &lt;a href=&#34;https://netmemo.github.io/post/tf-workspace-var&#34;&gt;terraform workspace&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      - name: Terraform Init
        id: init
        run: terraform init
        env:
          TF_WORKSPACE: &amp;quot;dev&amp;quot;

      - name: Terraform Workspace
        id: workspace
        run: terraform workspace select dev
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We then validate the Terraform configuration&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      - name: Terraform Validate
        id: validate
        run: terraform validate -no-color
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This step is to execute the Terraform plan. The plan will be a speculative plan executed in Terraform Cloud. Speculative plans are not directly visible from the Terraform Cloud UI. To access it, you will need to click on the link given in the result of the Terraform plan command.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      - name: Terraform Plan
        id: plan
        run: terraform plan -no-color
        continue-on-error: true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This step will execute a &lt;a href=&#34;https://github.com/marketplace/actions/github-script?version=v4.0.2&#34;&gt;github-script&lt;/a&gt; that will send a REST API query thanks to the &lt;em&gt;github&lt;/em&gt; pre-authenticated &lt;a href=&#34;https://octokit.github.io/rest.js/v18&#34;&gt;octokit/rest.js&lt;/a&gt; client with pagination plugins. It will also create a comment on the commit with the result of the previous steps.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      - uses: actions/github-script@0.9.0
        if: github.event_name == &#39;push&#39;
        env:
          PLAN: &amp;quot;terraform\n${{ steps.plan.outputs.stdout }}&amp;quot;
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const output = `#### Terraform Format and Style [36;63H\`${{ steps.fmt.outcome }}\`
            #### Terraform Initialization ⚙️\`${{ steps.init.outcome }}\`
            #### Terraform Validation [36;41H\`${{ steps.validate.outcome }}\`
            #### Terraform Plan [36;35H\`${{ steps.plan.outcome }}\`
            &amp;lt;details&amp;gt;&amp;lt;summary&amp;gt;Show Plan&amp;lt;/summary&amp;gt;
            \`\`\`\n
            ${process.env.PLAN}
            \`\`\`
            &amp;lt;/details&amp;gt;
            *Pusher: @${{ github.actor }}, Action: \`${{ github.event_name }}\`*`;
            github.repos.createCommitComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              commit_sha: context.sha,
              body: output
            })
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This step is to apply the Terraform configuration, only if the &lt;em&gt;terraform plan&lt;/em&gt; step result has succeeded.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      - name: Terraform Apply
        id: apply
        if: steps.plan.outcome == &#39;success&#39;
        run: terraform apply -auto-approve
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the &lt;em&gt;terraform apply&lt;/em&gt; succeeds, we will use the &lt;a href=&#34;https://github.com/marketplace/actions/github-script?version=v4.0.2&#34;&gt;github-script&lt;/a&gt; to create a &lt;a href=&#34;https://octokit.github.io/rest.js/v18#pulls-create&#34;&gt;Pull Request&lt;/a&gt; thanks to the &lt;a href=&#34;https://octokit.github.io/rest.js/v18&#34;&gt;octokit/rest.js&lt;/a&gt; like in the previous steps.
We will use a personal github token &lt;em&gt;PERSO_GITHUB_TOKEN&lt;/em&gt; to create the PR for these steps. If we are not using the personal token, the &lt;a href=&#34;https://github.com/peter-evans/create-pull-request/issues/48&#34;&gt;PR will not trigger other pipelines&lt;/a&gt; that have the &lt;em&gt;on:pull_request trigger&lt;/em&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      - name: CreatePR if apply succeed
        uses: actions/github-script@v4.0.2
        if: steps.apply.outcome == &#39;success&#39;
        with:
          github-token: ${{ secrets.PERSO_GITHUB_TOKEN }}
          script: |
            github.pulls.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: &amp;quot;Auto PR&amp;quot;,
              head: &amp;quot;dev&amp;quot;,
              base: &amp;quot;main&amp;quot;
            });
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;plan-prod-yml&#34;&gt;plan-prod.yml&lt;/h4&gt;

&lt;p&gt;The plan-prod.yml Github Actions YAML file will be executed only after a &lt;em&gt;pull request&lt;/em&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;on:
  pull_request:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Most of the steps have already been described for the &lt;em&gt;dev-to-pr.yml&lt;/em&gt; files, the only difference is the step below.
It will add a comment on the PR with the description of what has been done.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      - uses: actions/github-script@v4.0.2
        env:
          PLAN: &amp;quot;terraform\n${{ steps.plan.outputs.stdout }}&amp;quot;
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const output = `#### Terraform Initialization ⚙️\`${{ steps.init.outcome }}\`
            #### Terraform Validation [36;41H\`${{ steps.validate.outcome }}\`
            #### Terraform Plan [36;35H\`${{ steps.plan.outcome }}\`
            &amp;lt;details&amp;gt;&amp;lt;summary&amp;gt;Show Plan&amp;lt;/summary&amp;gt;
            \`\`\`\n
            ${process.env.PLAN}
            \`\`\`
            &amp;lt;/details&amp;gt;
            *Pusher: @${{ github.actor }}, Action: \`${{ github.event_name }}\`*`;
            github.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: output
            })
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;apply-prod-yml&#34;&gt;apply-prod.yml&lt;/h4&gt;

&lt;p&gt;The plan-prod.yml Github Actions YAML file will be executed only after a &lt;em&gt;push&lt;/em&gt; on the main branch.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;on:
  push:
    branches:
      - main
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The other steps have already been discussed previously.&lt;/p&gt;

&lt;h2 id=&#34;terraform-file&#34;&gt;Terraform file&lt;/h2&gt;

&lt;p&gt;For this blog post we will have a single main.tf file.
This Terraform script should have the terraform configuration, the provider definition and the resources definitions.&lt;/p&gt;

&lt;h4 id=&#34;terraform-variables&#34;&gt;Terraform variables&lt;/h4&gt;

&lt;p&gt;This is where we declare the Terraform variables that will be defined in the Terrafrom Cloud workspaces. These variables will change according to the environment.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;variable &amp;quot;password&amp;quot; {
  type = string
}
variable &amp;quot;username&amp;quot; {
  type = string
}
variable &amp;quot;nsxhost&amp;quot; {
  type = string
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;terraform-configuration-section&#34;&gt;Terraform configuration section&lt;/h4&gt;

&lt;p&gt;In this section we are setting the 2 providers needed and the backend.
The &lt;em&gt;backend &amp;ldquo;&lt;a href=&#34;https://www.terraform.io/docs/language/settings/backends/remote.html#workspaces&#34;&gt;remote&lt;/a&gt;&amp;ldquo;&lt;/em&gt; is where you find the Terraform Cloud organization and workspaces prefixes.
The workspaces suffixes will be added as seen in the beginning of this post with the &lt;a href=&#34;https://learn.hashicorp.com/tutorials/terraform/automate-terraform?in=terraform/automation&#34;&gt;TF_WORKSPACE&lt;/a&gt; environment variables and the &lt;a href=&#34;https://www.terraform.io/docs/language/settings/backends/remote.html#workspaces&#34;&gt;terraform workspace select&lt;/a&gt; command in the Github Actions steps.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;terraform {
  required_providers {
    random = {
      source = &amp;quot;hashicorp/random&amp;quot;
      version = &amp;quot;3.0.1&amp;quot;
    }
    nsxt = {
      source = &amp;quot;vmware/nsxt&amp;quot;
      version = &amp;quot;&amp;gt;= 3.1.1&amp;quot;
    }
  }

  backend &amp;quot;remote&amp;quot; {
    organization = &amp;quot;netmemo&amp;quot;

    workspaces {
      prefix = &amp;quot;netmemo-&amp;quot;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;provider-configuration&#34;&gt;Provider configuration&lt;/h4&gt;

&lt;p&gt;This is the NSX-T provider configuration. We pass the 3 variables that are defined in the Terraform Cloud workspaces.
We disable the SSL verification because this is a local lab.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;provider &amp;quot;nsxt&amp;quot; {
    host = var.nsxhost
    username = var.username
    password = var.password
    allow_unverified_ssl = true
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;resource-creation&#34;&gt;Resource creation&lt;/h4&gt;

&lt;p&gt;For this blog post we will create a &lt;a href=&#34;https://registry.terraform.io/providers/vmware/nsxt/latest/docs/resources/policy_tier1_gateway&#34;&gt;NSX-T T1 gateway&lt;/a&gt; name &lt;strong&gt;T1-TFC&lt;/strong&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;resource &amp;quot;nsxt_policy_tier1_gateway&amp;quot; &amp;quot;tier1_gw&amp;quot; {
  description               = &amp;quot;Tier-1 provisioned by Terraform&amp;quot;
  display_name              = &amp;quot;T1-TFC&amp;quot;
  route_advertisement_types = [&amp;quot;TIER1_CONNECTED&amp;quot;]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;project-workflow&#34;&gt;Project workflow&lt;/h1&gt;

&lt;p&gt;Clic the arrows to see the detail.
&lt;details&gt;
&lt;summary&gt;1. Modify the dev branch on you local git.&lt;/summary&gt;
&lt;/details&gt;
&lt;details&gt;
&lt;summary&gt;2. Add the modif to git, commit them and push the dev branch to your github repo.&lt;/summary&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git add .

git commit -am &amp;quot;add T1-GW&amp;quot;
[dev a0b946b] add T1-GW
 2 files changed, 6 insertions(+), 6 deletions(-)

git push
Counting objects: 6, done.
Delta compression using up to 2 threads.
Compressing objects: 100% (5/5), done.
Writing objects: 100% (6/6), 617 bytes | 617.00 KiB/s, done.
Total 6 (delta 2), reused 0 (delta 0)
remote: Resolving deltas: 100% (2/2), completed with 2 local objects.
To ssh://github.com/netmemo/tf-gha-nsxt-cicd.git
   8534543..a0b946b  dev -&amp;gt; dev
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/details&gt;
&lt;details&gt;
&lt;summary&gt;3. Dev pipeline&lt;/summary&gt;
The dev pipeline is triggered, you can see it&amp;rsquo;s starting in the Actions tab. It&amp;rsquo;s tittle will be the commit message.&lt;br /&gt;
&lt;a href=&#34;workflow-start.png&#34;&gt; &lt;img src=&#34;workflow-start.png&#34; alt=&#34;&#34; /&gt; &lt;/a&gt;
To validate that the dev pipeline is completed, you can check the Terraform cloud dev workspace state and the NSX-T dev environment to see that there is a new T1-GW.
&lt;a href=&#34;tfc-state-dev-after.png&#34;&gt; &lt;img src=&#34;tfc-state-dev-after.png&#34; alt=&#34;&#34; /&gt; &lt;/a&gt;
&lt;/details&gt;
&lt;details&gt;
&lt;summary&gt;4. Integration pipeline&lt;/summary&gt;
After all the steps in the dev pipeline are passed, the workflow will turn green. The last step of the pipeline will create an automatic PR that will trigger the integration pipeline. This pipeline will validate the configuration and creates a plan against the production environment.
The PR will have the description &lt;strong&gt;&amp;ldquo;Auto PR generate by Github Action dev pipeline&amp;rdquo;&lt;/strong&gt;
&lt;a href=&#34;pr-list.png&#34;&gt; &lt;img src=&#34;pr-list.png&#34; alt=&#34;&#34; /&gt; &lt;/a&gt;
The integration pipeline will execute the &lt;em&gt;terraform plan&lt;/em&gt; command against the production environment. You can then check again the Actions tab to see that the development and integration pipeline has turned green.
&lt;a href=&#34;workflow-2-pipeline-ok.png&#34;&gt; &lt;img src=&#34;workflow-2-pipeline-ok.png&#34; alt=&#34;&#34; /&gt; &lt;/a&gt;
If the two pipelines are ok, the checks in the PR should be green.&lt;br /&gt;
&lt;a href=&#34;\pr-test-ok.png&#34;&gt; &lt;img src=&#34;pr-test-ok.png&#34; alt=&#34;&#34; /&gt; &lt;/a&gt;
&lt;/details&gt;
&lt;details&gt;
&lt;summary&gt;5. Merge&lt;/summary&gt;
When the dev and integration pipeline are finished, the dev branch is ready to be merged to the main branch. You can then clic on the &lt;strong&gt;Merge pull request&lt;/strong&gt; button to validate the merge and trigger the deployment pipeline.
&lt;a href=&#34;going-to-prod.png&#34;&gt; &lt;img src=&#34;going-to-prod.png&#34; alt=&#34;&#34; /&gt; &lt;/a&gt;
&lt;a href=&#34;pr-merged.png&#34;&gt; &lt;img src=&#34;pr-merged.png&#34; alt=&#34;&#34; /&gt; &lt;/a&gt;
&lt;/details&gt;
&lt;details&gt;
&lt;summary&gt;6. Deployment pipeline&lt;/summary&gt;
The deployment pipeline is triggered with the push/merge to the main branch. This is the final workflow that will push the Terraform configuration to production. You can see in Terraform Cloud that Terraform is applying the configuration.
&lt;a href=&#34;tfc-prod-applying.png&#34;&gt; &lt;img src=&#34;tfc-prod-applying.png&#34; alt=&#34;&#34; /&gt; &lt;/a&gt;
You can now double check in Github Actions that the deployment workflow has been succefully executed, &lt;strong&gt;&amp;ldquo;Merge pull request #10&amp;rdquo;&lt;/strong&gt; in the picture below.
&lt;a href=&#34;pipeline-apply-ok-list.png&#34;&gt; &lt;img src=&#34;pipeline-apply-ok-list.png&#34; alt=&#34;&#34; /&gt; &lt;/a&gt;
&lt;/details&gt;
&lt;details&gt;
&lt;summary&gt;7. Checks&lt;/summary&gt;
Finally you can now verify that there is a resource on Terraform Cloud and that the T1 Gateway has been created on the production NSX-T.&lt;br /&gt;
&lt;a href=&#34;tfc-prod-ok.png&#34;&gt; &lt;img src=&#34;tfc-prod-ok.png&#34; alt=&#34;&#34; /&gt; &lt;/a&gt;
&lt;a href=&#34;nsxt-prod-ok.png&#34;&gt; &lt;img src=&#34;nsxt-prod-ok.png&#34; alt=&#34;&#34; /&gt; &lt;/a&gt;
&lt;/details&gt;&lt;/p&gt;

&lt;h1 id=&#34;how-to-test-this-project&#34;&gt;How to test this project.&lt;/h1&gt;

&lt;p&gt;Requirements:&lt;br /&gt;
- NSX-T environment (there are examples on the web to use AWS as provider instead of NSX, the concepts are the same).&lt;br /&gt;
- Terraform Cloud account with 2 workspaces.&lt;br /&gt;
- Github account and git locally.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;[NSX-T]&lt;/strong&gt; Prepare your two NSX-T environments.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;[TFC]&lt;/strong&gt; Create your two workspaces in TFC with the API Key for Github.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;[GITHUB]&lt;/strong&gt; Fork this &lt;a href=&#34;https://github.com/netmemo/tf-gha-nsxt-cicd&#34;&gt;project&lt;/a&gt;, add the TFC API key and your personal API Key to your repo, enable actions.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;[LOCAL]&lt;/strong&gt; Clone your forked project to your local git.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;[LOCAL]&lt;/strong&gt; Create the dev branch locally.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;[LOCAL]&lt;/strong&gt; Modify the Terraform configuration in the main.tf according to your TFC workspace.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;[LOCAL]&lt;/strong&gt; Add to git, commit, push.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;[GITHUB]&lt;/strong&gt; Wait until all the test pass.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;[GITHUB]&lt;/strong&gt; Click merge to deploy to prod.&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;pain-points-of-the-project&#34;&gt;Pain points of the project.&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Switching &lt;a href=&#34;https://netmemo.github.io/post/tf-workspace-var&#34;&gt;terraform workspace&lt;/a&gt; with github actions.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Create &lt;a href=&#34;https://netmemo.github.io/post/gha-auto-pr&#34;&gt;automatically&lt;/a&gt; a github PR with with rest.js API of octokit.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;script src=&#34;https://utteranc.es/client.js&#34;
        repo=&#34;[ENTER REPO HERE]&#34;
        issue-term=&#34;pathname&#34;
        theme=&#34;github-dark&#34;
        crossorigin=&#34;anonymous&#34;
        async&gt;
&lt;/script&gt;
</description>
    </item>
    
  </channel>
</rss>
